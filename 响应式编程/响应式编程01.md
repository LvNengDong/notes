响应式编程是一种新的编程技术，其目的是构建响应式系统。对于响应式系统而言，任何时候都需要确保具备即时响应性，这是大多数日常业务场景所需要的，但却是一项非常复杂而有挑战性的任务，需要对相关技术体系有深入的了解。
那么在今天的课程中，我会先从传统的开发模式讲起，并引入异步执行的相关技术，因为异步执行是响应式技术体系的基础。在此基础上，我将为你详细阐述响应式编程的各项技术特点。

# 从传统开发模式到异步执行技术

现实的开发过程普遍采用的是同步阻塞式的开发模式，以实现业务系统。在这种模式下，开发、调试和维护都很简单。我们先以 Web 系统中最常见的 HTTP 请求为例，来分析其背后的 I/O 模型，从而让你对传统开发模式有进一步的了解。

## Web 请求与 I/O 模型

如果你使用 Spring 框架开发过 Web 应用程序，那么你一定对下面这段代码非常熟悉。

```java
RestTemplate restTemplate = new RestTemplate();
ResponseEntity<User> restExchange = restTemplate.exchange(
    "http://localhost:8080/users/{userName}", HttpMethod.GET, null, User.class, userName);
User result = restExchange.getBody();
process(result);  
```

这里，我们传入用户名 UserName 调用远程服务获取一个 User 对象，技术上使用了 Spring MVC 中的 RestTemplate 模板工具类，通过该类所提供的 exchange 方法对远程 Web 服务所暴露的 HTTP 端点发起了请求，并对所获取的响应结果进行进一步处理。

这是日常开发过程中非常具有代表性的一种场景，整个过程很熟悉也很自然。

那么，这个实现过程背后有没有一些可以改进的地方呢？为了更好地分析整个调用过程，我们假设服务的提供者为服务 A，而服务的消费者为服务 B，那么这两个服务的交互过程应该是下图所示这样的。

![](https://s0.lgstatic.com/i/image6/M00/21/36/Cgp9HWBUHYyAWK7RAACbGUwiNJI141.png)

​																图 1 服务 A 和服务 B 的交互过程图

可以看到，当服务 B 向服务 A 发送 HTTP 请求时，线程 B 只有在发起请求和响应结果的一小部分时间内在有效使用 CPU，而更多的时间则只是在阻塞式地等待来自服务 A 中线程的处理结果。显然，整个过程的 CPU 利用效率是很低的，很多时间线程被浪费在了 I/O 阻塞上，无法执行其他的处理过程。

更进一步，我们继续分析服务 A 中的处理过程。如果我们采用典型的 Web 服务分层架构，那么就可以得到如图 2 所示的用户信息查询实现时序图，这是日常开发过程中普遍采用的一种实现方式。

一般我们使用 Web 层所提供的 HTTP 端点作为查询的操作入口，然后该操作入口会进一步调用包含业务逻辑处理的服务层，而服务层再调用数据访问层，数据访问层就会连接到数据库获取数据。数据从数据库中获取之后逐层向上传递，最后返回给服务的调用者。

![](https://s0.lgstatic.com/i/image6/M01/21/34/CioPOWBUIG2APMzTAAG4Hgs9bQk059.png)

​												图 2 基于传统实现方法的用户信息查询场景时序图

显然图 2 所展示的整个过程中，每一步的操作过程都存在着前面描述的线程等待问题。也就是说，整个技术栈中的每一个环节都可能是同步阻塞的。

针对同步阻塞问题，在技术上也可以引入一些实现技术来将同步调用转化为异步调用。我们一起来看一下。

## 异步调用的实现技术

在 Java 世界中，为了实现异步非阻塞，一般会采用回调和 Future 这两种机制，但这两种机制都存在一定局限性。

回调的含义如图 3 所示，即服务 B 的 methodB() 方法调用服务 A 的 methodA() 方法，然后服务 A 的 methodA() 方法执行完毕后，再主动调用服务 B 的 callback() 方法。

![](https://s0.lgstatic.com/i/image6/M01/21/34/CioPOWBUIHmAV0OeAACBv4hHbo0240.png)

回调体现的是一种双向的调用方式，实现了服务 A 和服务 B 之间的解耦。在这个 callback 回调方法中，回调的执行是由任务的结果来触发的，所以我们就可以异步来执行某项任务，从而使得调用链路不发生任何的阻塞。

回调的最大问题是复杂性，一旦在执行流程中包含了多层的异步执行和回调，那么就会形成一种嵌套结构，给代码的开发和调试带来很大的挑战。所以回调很难大规模地组合起来使用，因为很快就会导致代码难以理解和维护，从而造成所谓的“回调地狱”问题。

讲完回调，我们来看 Future。可以把 Future 模式简单理解为这样一种场景：我们有一个需要处理的任务，然后把这个任务提交到 Future，Future 就会在一定时间内完成这个任务，而在这段时间内我们可以去做其他事情。作为 Future 模式的实现，Java 中的 Future 接口只包含如下 5 个方法。

```java
public interface Future<V> {

    //取消任务的执行
    boolean cancel(boolean mayInterruptIfRunning);

    //判断任务是否已经取消
    boolean isCancelled();

    //判断任务是否已经完成
    boolean isDone();

    //等待任务执行结束并获取结果
    V get() throws InterruptedException, ExecutionException;

    //在一定时间内等待任务执行结束并获取结果
    V get(long timeout, TimeUnit unit)?
        throws InterruptedException, ExecutionException, TimeoutException;
}
```

从这些基础方法中可以看到，我们可以通过对任务进行灵活的控制和判断，来达到一定的异步执行效果。

但从本质上讲，Future 以及由 Future 所衍生出来的 CompletableFuture 等各种优化方案就是一种多线程技术。多线程假设一些线程可以共享一个 CPU，而 CPU 时间能在多个线程之间共享，这一点就引入了“上下文切换”的概念。

如果想要恢复线程，就需要涉及加载和保存寄存器等一系列计算密集型的操作。因此，大量线程之间的相互协作同样会导致资源利用效率低下。

那么以上我们对传统开发模式以及异步调用实现方式做了一些回顾，下面引出本讲的重点内容——响应式编程实现方法。



## 响应式编程实现方法

### 观察者模式和发布-订阅模式

在引入响应式编程技术之前，我们同样先来回顾一个大家可能都知道的设计模式，即观察者模式。观察者模式拥有一个主题（Subject），其中包含其依赖者列表，这些依赖者被称为观察者（Observer）。主题可以通过一定的机制将任何状态变化通知到观察者。针对前面介绍的用户信息查询操作，我们同样可以应用观察者模式，如下图所示。

![](https://s0.lgstatic.com/i/image6/M01/21/34/CioPOWBUIISALAvPAACra6PO8ac132.png)

​																	图 4 观察者模式下的用户信息获取过程

如果系统中存在一批类似上图中的用户信息获取场景，针对每个场景都实现一套观察者模式显然是不合适的。更好的方法是使用发布-订阅模式，该模式可以认为是对观察者模式的一种改进。

在这一模式中，发布者和订阅者之间可以没有直接的交互，而是通过发送事件到事件处理平台的方式来完成整合，如下图所示。

![](https://s0.lgstatic.com/i/image6/M01/21/34/CioPOWBUIIuAWD5cAAC5GORZj7Y689.png)

​																	图 5 发布-订阅模式下的用户信息获取过程

由此可见，通过发布-订阅模式，我们可以基于同一套事件发布机制和事件处理平台来应对多种业务场景，不同的场景只需要发送不同的事件即可。

同样，如果我们聚焦于服务 A 的内部，那么从 Web 服务层到数据访问层，再到数据库的整个调用链路，同样可以采用发布-订阅模式进行重构。这时候，我们希望当数据库中的数据一有变化就通知上游组件，而不是上游组件通过主动拉取数据的方式来获取数据。下图展示了这一过程。

![](https://s0.lgstatic.com/i/image6/M01/21/38/Cgp9HWBUIJSAXaqcAAH7KKi1LAk978.png)

​															图 6 基于响应式实现方法的用户信息查询场景时序图

显然，现在我们的处理方式发生了本质性的变化。图 6 中，我们没有通过同步执行的方式来获取数据，而是订阅了一个 UserChangedEvent 事件。UserChangedEvent 事件会根据用户信息是否发生变化而进行触发，并在 Web 应用程序的各个层之间进行传播。如果我们在这些层上都对这个事件进行了订阅，那么就可以对其分别进行处理，并最终将处理结果从服务 A 传播到服务 B 中。



#### 数据流与响应式

接下来，我们扩大讨论范围，来想象系统中可能会存在着很多类似 UserChangedEvent 这样的事件。每一种事件会基于用户的操作或者系统自身的行为而被触发，并形成了一个事件的集合。针对事件的集合，我们可以把它们看成是一串串联起来的数据流，而系统的响应能力就体现在对这些数据流的即时响应过程上。

数据流对于技术栈而言是一个全流程的概念。也就是说，无论是从底层数据库，向上到达服务层，最后到 Web 服务层，抑或是在这个流程中所包含的任意中间层组件，整个数据传递链路都应该是采用事件驱动的方式来进行运作的。

这样，我们就可以不采用传统的同步调用方式来处理数据，而是由处于数据库上游的各层组件自动来执行事件。**这就是响应式编程的核心特点**。

相较传统开发所普遍采用的“拉”模式，在响应式编程下，基于事件的触发和订阅机制，这就形成了一种类似“推”的工作方式。这种工作方式的优势就在于，生成事件和消费事件的过程是异步执行的，所以线程的生命周期都很短，也就意味着资源之间的竞争关系较少，服务器的响应能力也就越高。

## 响应式宣言和响应式系统

讲到这里，在理论和实践的结合下，你应该已经意识到，所谓的“响应式”并不是一件颠覆式的事情，而只是一种新型的编程模式。它不局限于某种开发框架，也并非解决分布式环境下所有问题的银弹，而是随着技术的发展自然而然诞生的一种技术体系。

关于响应式，业界也存在一个著名的响应式宣言，下图就是响应式宣言的官方网站给出的，对于这一宣言的图形化描述。

![](https://s0.lgstatic.com/i/image6/M01/21/35/CioPOWBUIJ6AeBjQAADBZrcBck4263.png)

​																								图 7 响应式宣言

可以看到，即时响应性（Responsive）、回弹性（Resilient）、弹性（Elastic）以及消息驱动（Message Driven）构成了响应式宣言的主体内容。响应式宣言认为，具备上图中各个特性的系统，就可以称为响应式系统。

而这些特性又可以分为三个层次，其中即时响应性、可维护性（Maintainable）和扩展性（Extensible）体现的是价值，回弹性和弹性是表现形式，而消息驱动则是实现手段。

从设计理念上讲，即时响应性指的就是无论在任何时候，系统都会及时地做出响应，并对那些出现的问题进行快速的检测和处理，这是可用性的基石。

要注意，这里的回弹性和弹性比较容易混用。**所谓回弹性指的是系统在出现失败时，依然能够保持即时响应性；而弹性则是指的系统在各种请求压力之下，都能保持即时响应性**。

最后的消息驱动指的是响应式系统需要构建异步的消息通信机制。你可以把这里的消息等同于前面提到的事件，通过使用消息通信，可以通过在系统中实现连续的数据流，从而达到对流量进行控制的管理目标。我们知道消息通信是非阻塞的，非阻塞的通信使得只有在有消息到来时才需要资源的投入，而避免了很多同步等待导致的资源浪费。





# 背压机制

## 流的概念

响应式编程中的流就是`由生产者（Publisher）生产并由一个或多个消费者（Subscriber）消费的元素序列`。这种 `生产者/消费者模型` 也可以被称为 `发布者/订阅者模型`。

而关于流的学习，我们可以从两方面入手，首先明确流的分类，然后再来讨论如何进行流量控制，流量控制是讨论数据流的核心话题。

## 流的处理模型

关于流的处理，存在两种基本的实现机制。一种就是传统开发模式下的“拉”模式，即消费者主动从生产者拉取元素（同步阻塞等待）；而另一种就是基于监听器设计模式的“推”模式，在这种模式下，生产者将元素推送给消费者。相较于“拉”模式，“推”模式下的数据处理的资源利用率更好，下图所示的就是一种典型的推模式处理流程。

![](https://s0.lgstatic.com/i/image6/M01/21/38/Cgp9HWBUIRCAHSoEAACQmzpsJME739.png)

​																	图 1 推模式下的数据流处理方式示意图

上图中，数据流的生产者会持续地生成数据并推送给消费者。这就引出了流量控制问题，即如果数据的生产者和消费者处理数据的速度是不一致的，我们应该如何确保系统的稳定性呢？

## 流量控制

### Case1：生产速度<消费速度

对于生产者生产数据的速率小于消费者的场景。在这种情况下，因为消费者消费数据没有任何压力，也就不需要进行流量的控制。

### Case2：生产速度>消费速度

现实中，更多的是生产者生产数据的速率大于消费者消费数据的场景。这种情况比较复杂，因为消费者可能因为无法处理过多的数据而发生崩溃。针对这种情况的一种常见解决方案是在生产者和消费者之间添加一种类似于消息队列的机制。队列具有存储并转发的功能，所以可以由它来进行一定的流量控制，效果如下图所示。

![](https://s0.lgstatic.com/i/image6/M00/21/35/CioPOWBUIRiAedZZAACVgTxgC80957.png)

图 2 添加队列机制之后的生产者/消费者场景示意图

现在，问题的关键就转变为**如何设计一种合适的队列**。通常，我们可以选择三种不同类型的队列来分别支持不同的功能特性。

**无界队列**

第一种最容易想到的队列就是无界队列（Unbounded Queue），这种队列原则上拥有无限大小的容量，可以存放所有生产者所生产的消息，如下图所示。

![](https://s0.lgstatic.com/i/image6/M01/21/38/Cgp9HWBUISGAJrh5AACOo3oalK8601.png)

显然，无界队列的优势就是确保了所有消息都能得到消费，但没有一个系统拥有无限的资源，一旦内存等资源被耗尽，系统可能就崩溃了。

**有界丢弃队列**

与无界队列相对的，更合适的方案是选择一种有界队列。为了避免内存溢出，我们可以使用这样一个队列，一般队列的容量满了，就忽略后续传入的消息，如下图所示。

![](https://s0.lgstatic.com/i/image6/M00/21/35/CioPOWBUISqAal3JAACp2GTWvZM658.png)

图 4 有界丢弃队列结构示意图

上图中，可以看出这个有界队列的容量为 6，所以第 7 和第 8 个元素被丢弃了。然后当消费者消费了一部分消息之后，队列出现了新的空闲位置，后续的消息就又被填充到队列中。当然，这里可以设置一些丢弃元素的策略，比方说按照优先级或先进先出等。

有界丢弃队列考虑了资源的限制，比较适合用于允许丢消息的业务场景，但在消息重要性很高的场景显然不可能采取这种队列。

**有界阻塞队列**

如果需要确保消息不丢失，则需要引入有界阻塞队列。在这种队列中，我们会在队列消息数量达到上限后阻塞生产者，而不是直接丢弃消息，如下图所示。

![](https://s0.lgstatic.com/i/image6/M01/21/38/Cgp9HWBUIUOAChJ1AACq6l5LR5Y136.png)

​										图 5 有界阻塞队列结构示意图

上图中，队列的容量同样是 6，所以当第 7 个元素到来时，发现队列已经满了，那么生产者就会一直等到队列空间的释放而产生阻塞行为。显然，这种阻塞行为是不可能实现异步操作的，所以结合上一讲中的讨论结果，无论从回弹性、弹性还是即时响应性出发，有界阻塞队列都不是我们想要的解决方案。



## 背压机制

讲到这里，我们已经明确，纯“推”模式下的数据流量会有很多不可控制的因素，并不能直接应用，而是需要在“推”模式和“拉”模式之间考虑一定的平衡性，从而优雅地实现流量控制。这就需要引出响应式系统中非常重要的一个概念——**背压机制（Backpressure）**。

什么是背压？简单来说就是`下游能够向上游反馈流量请求的机制`。通过前面的分析，我们知道如果消费者消费数据的速度赶不上生产者生产数据的速度时，生产者就会持续消耗系统的资源，直到这些资源被消耗殆尽。

这个时候，就需要有一种机制使得消费者可以根据自身当前的处理能力通知生产者来调整生产数据的速度，这种机制就是背压。采用背压机制，消费者会根据自身的处理能力来请求数据，而生产者也会根据消费者的能力来生产数据，从而在两者之间达成一种动态的平衡，确保系统的即时响应性。



## 响应式流规范

关于流量控制的理论我们已经讨论了很多，而针对流量控制的解决方案以及背压机制都包含在响应式流规范中，其中包含了响应式编程的各个核心组件。

> **响应式编程的设计理念是基于监听器模式的，因此主体的数据传输流程是发布者流向订阅者的！！！**

### 响应式流的核心接口

在 Java 中，响应式流规范只定义了四个核心接口，即 `Publisher<T>`、`Subscriber<T>`、`Subscription` 和 `Processor<T,R>`

#### `Publisher<T>`

Publisher 代表的是一种可以生产无限数据的发布者，该接口定义如下所示。

```java
public interface Publisher<T> {
    /*
    	注意：这里是一种监听器模式的实现，所以这里的执行逻辑是
    	产生数据的发布者主动向一个订阅者发送数据。
    	同时，发布者内部会持有订阅者实例，当订阅者请求的事件得到
    	回复时，会触发 subscribe 方法向订阅者发送事件的处理结果。
    */
    public void subscribe(Subscriber<? super T> s);
}
```

Publisher 通过 subscribe 方法向订阅者 Subscriber 发送请求处理结果。

> **注：**Publisher 首先会和 Subscriber 建立连接，并且 Subscriber 会向 Publisher 发送一次异步请求，表明自己希望能够得到多少个响应结果。之后等这个异步请求得到响应时，会先被 Publisher 拦截，再由 Publisher 通过 subscribe 方法将请求结果发送给 Subscriber。



**注意事项：**

- Publisher 向 Subscriber 发送的 onNext 信号次数不得超过订阅者请求的元素个数（onNext 方法的作用是向下游传播数据，每调用一次 onNext 向下游传递一个数据结果）

- 如果 Publisher 发现任务执行失败了，需要调用 onError 告知订阅者。

- Publisher#subscribe 方法内部必须调用 Subscriber#onSubscribe 方法。

	> onSubscribe 方法：onSubscribe() 从命名上看就是一个回调方法，当发布者调用 subscribe() 方法时就会触发这个回调，而我们知道如果 subscribe() 方法被调用，就说明事件被执行了，也就是异步调用产生了返回结果。此时需要执行 subscribe 方法，而 subscribe 方法内部则会先调用 onSubscribe() 方法，它的作用是让订阅者做好初始化，准备开始接收后面的元素。

- 一个发布者允许同时存在多个订阅者。





#### `Subscriber<T>`

对应的，Subscriber 代表的是一种可以从发布者那里**订阅**并**接收元素**的订阅者。`Subscriber<T>` 接口定义如下所示。

```java
public interface Subscriber<T> {
    /*
    	建立发布者与订阅者之间的关系。因为订阅者发起的请求是一个异步请求，
    	当订阅者发出请求后不会阻塞等待，而是会先去执行其它任务。当订阅
    	者的请求产生结果后，发布者需要将结果交给订阅者，这里就是通过回调函数
    	来实现的。
    */
    public void onSubscribe(Subscription s);
    public void onNext(T t);
    public void onError(Throwable t);
    public void onComplete();
}
```

Subscriber 接口包含的这组方法构成了数据流请求和处理的基本流程。

其中，onSubscribe() 从命名上看就是一个回调方法，当发布者的 subscribe() 方法被调用时就会触发这个回调。在该方法中有一个参数 Subscription，可以把这个 Subscription 看作是一种用于订阅的上下文对象，Subscription 对象中包含了订阅者想要向发布者请求的数据个数。

当确定请求数据的个数后，线程就可以调用订阅者的 onNext() 方法向订阅者发送一个数据。这个过程是持续不断的，直到所发送的数据已经达到订阅者所请求的数据个数。这时候 onComplete() 方法就会被触发，代表这个数据流已经全部发送结束。而一旦在这个过程中出现了异常，那么就会触发 onError() 方法，我们可以通过这个方法捕获到具体的异常信息进行处理，而数据流也就自动终止了。

异步序列模型的执行过程可用如下公式表示：

```xml
onSubscribe onNext x 0..N [onError | onComplete]

>> 通过subscribe建立发布订阅关系 
>> 发布者调用onNext方法，发送数据，直到完成发送的个数 
>> 发送完成会触发onComplete方法，异常则触发onError方法，数据流也会停止。
```



**注意事项：**

- 为了接收到 onNext 发送的信号，订阅者必须通过 Subscription#request(long n) 方法来向发布者请求希望得到的数据个数。
- 只能存在一个活跃的订阅。（如果当前 Subscriber 已经有了一个活跃的订阅的话，它在接收到另一个 Publisher 传递的 onSubscribe 方法时，必须调用 Subscription#cancel 来取消另外一个订阅，这样就能保证订阅者不会同时与多个发布者产生交互）
- Subscriber 在调用 Subscription#cancel 之后，仍有可能接收到 onNext 信号发送的数据。这是因为 发布者不一定会立即执行 cancel，所以在正式 cancel 之前仍然可能有一部分响应会发送给下游，此时 Subscription 仍然需要处理这一部分元素。



#### Subscription

Subscription 代表的就是一种订阅上下文对象，它在订阅者和发布者之间进行传输，表明两者之间的一种契约关系。

Subscription 接口定义如下所示。

```java
public interface Subscription {
    public void request(long n);
    public void cancel();
}
```

这里的 request() 方法用于请求 n 个元素，订阅者可以通过不断调用该方法来向发布者请求数据；而 cancel() 方法显然是用来取消这次订阅。**Subscription 对象是确保生产者和消费者针对数据处理速度达成一种动态平衡的基础，也是流量控制中实现背压机制的关键所在。**



我们可以通过下图来进一步理解整个数据请求和处理过程。

![](https://s0.lgstatic.com/i/image6/M00/21/38/Cgp9HWBUIZqASTpVAADEEHREqvE168.png)

图 6 Subscription 与背压机制示意图

Publisher、Subscriber 和 Subscription 接口是响应式编程的核心组件，响应式流规范也只包含了这些接口，因此是一个非常抽象且精简的接口规范。结合前面的讨论结果，我们可以明确，响应式流规范实际上提供了一种“推-拉”结合的混合数据流模型。

当然，响应式流规范非常灵活，还可以提供独立的“推”模型和“拉”模型。如果为了实现纯“推”模型，我们可以考虑一次请求足够多的元素；而对于纯“拉”模型，相当于就是在每次调用 Subscriber 的 onNext() 方法时只请求一个新元素。



#### Proceor接口

Proceor 是一种处理的状态，所以，它既是一个 Publisher，也是一个 Subscriber。

在 Reactor2.5版本后已被弃用。



### 响应式流的技术生态圈

响应式流是一种规范，而该规范的核心价值就在于为业界提供了一种非阻塞式背压的异步流处理标准。各个供应商都可以基于该规范实现自己的响应式开发库，而这些开发库之间则可以做到互相兼容、相互交互。

目前，业界主流响应式开发库包括 RxJava、Akka、Vert.x 以及 Project Reactor。在本课程中，我们将重点介绍 Project Reactor，它是 Spring 5 中所默认集成的响应式开发库。





# 响应式编程的应用场景

## 响应式编程的应用场景分析

本质上，我们可以认为响应式编程并不仅仅是一种编程技术，而更是一种架构设计的系统方法，因此可以应用于任何地方。它既可以用于简单的 Web 应用系统，也可以用于大型企业解决方案。当然，对于响应式数据流，我们也完全可以基于它来构建流式系统或大数据系统。

数据流处理是响应式编程的一大应用场景。流式系统的主要特点是低延迟和高吞吐量。对于这类系统，大多数数据是从服务器端传出的，因此客户端扮演消费者的角色。这个时候，通过使用非阻塞式通信可以确保资源得到高效的利用，从而实现低延迟和高吞吐量。流式系统的表现形式也可以有很多，日常的日志埋点和分析、服务运行时的状态采集等都属于这种类型。

针对高并发流量，通常涉及大量的 I/O 操作。相较于传统的同步阻塞式 I/O 模型，响应式编程所具备的异步非阻塞式 I/O 模型非常适合应对处理高并发流量的业务场景。这类场景中比较典型的一种表现形式就是微服务架构中的 API 网关，因为网关的作用就是用来响应来自前端系统的流量并将其转发到后端服务。

讲到微服务架构，如何构建一个具有异步非阻塞式的请求处理流程的 Web 服务也是核心诉求，我们需要高效处理跨服务之间的网络请求。针对这种场景，响应式编程及其相关技术体系同样也是一种非常有效的解决方案。

## 响应式编程在主流开源框架中的应用

响应式编程在日常开发过程中日益得到广泛的应用，结合上文所分析的三种典型应用场景，这里我们以对应的 Netflix Hystrix、Spring Cloud Gateway 以及 Spring WebFlux 这三款主流的开源框架为例，解析这些框架背后所应用的响应式编程技术。

### Netflix Hystrix 中的滑动窗口

在 Spring Cloud 微服务开发框架中，存在一个 Spring Cloud Netflix Hystrix 组件，该组件基于 Netflix Hystrix 实现了服务熔断功能。Netflix Hystrix 是 Netflix 开源的一款容错库，使用了 HystrixCircuitBreaker 类来实现熔断器。该类通过一个 circuitOpen 状态位控制着整个熔断判断流程，而这个状态位本身的状态值则取决于系统目前的执行数据和健康指标。

那么，HystrixCircuitBreaker 如何动态获取系统运行时的各项数据呢？这里就使用到了一个 HealthCountsStream 类，从命名上不难看出，这就是一种数据流。HealthCountsStream 在设计上采用了一种特定的机制，即滑动窗口（Rolling Window）机制，而 Hystrix 在实现这一机制时大量采用了数据流处理方面的技术以及 RxJava 这个响应式编程框架。

Hystrix 以秒为单位来统计系统中所有请求的处理情况，然后每次取最近 10 秒的数据来进行计算。如果失败率超过一定阈值，就进行熔断。这里的 10 秒就是一个滑动窗口，参考其官网的一幅图，如下所示。

![](https://s0.lgstatic.com/i/image6/M00/24/07/Cgp9HWBYDkqAfjLrAAImzCk-l7s672.png)

图 1 Hystrix 滑动窗口效果图（来自 Hystrix 官网）

上图演示了 Hystrix 滑动窗口策略，把 10 秒时间拆分成了 10 个格子，我们把这种格子称为桶 Bucket。每个桶中的数据就是这一秒中所处理的请求数量，并针对处理结果的状态做了分类。然后每当收集好一个新的桶后，就会丢弃掉最旧的一个桶，所以窗口是滑动的。

那么如何来实现这个滑动窗口呢？我们转换一下思路，可以把系统运行时所产生的所有数据都视为一个个的事件，这样滑动窗口中每个桶的数据都来自源源不断的事件。同时，对于这些生成的事件，我们通常需要对其进行转换以便进行后续的操作。这两点构成了实现滑动窗口的设计目标和方法。

在技术实现的选型上，Hystrix 采用了基于响应式编程思想的 RxJava。与其他响应式编程框架一样，RxJava 同样实现了上一讲中介绍的响应式流规范。使用 RxJava 的一大好处是可以通过 RxJava 的一系列操作符来实现滑动窗口，包括 window、flatMap 和 reduce 等。其中 window 操作符是把当前流中的元素收集到另外的流序列；flatMap 操作符把流中的每个元素转换成一个流，再把转换之后得到的所有流中的元素进行合并。而后 reduce 操作符对流中包含的所有元素进行累积操作，得到一个包含计算结果的流。这些操作符我会在“07 | Reactor 操作符（上）：如何快速转换响应式流”中详细为你介绍。

在 Hystrix 中，HealthCountsStream 的子类 BucketedCounterStream 将基础数据事件流汇总成 Bucket，如下所示。

```java
this.bucketedStream = Observable.defer(new Func0<Observable<Bucket>>() {
            @Override
            public Observable<Bucket> call() {
                return inputEventStream
                        .observe()
	// 使用window操作符收集一个Bucket时间内的数据
.window(bucketSizeInMs, TimeUnit.MILLISECONDS) 
// 将每个window内聚集起来的事件集合汇总成Bucket
.flatMap(reduceBucketToSummary).startWith(emptyEventCountsToStart);                       }
	        });
```

可以看到，这里分别使用了前面介绍的 window 和 flatMap 操作符来完成 Bucket 的构建。请注意，该方法返回的是一个 Observable`<Bucket>` 对象。在 RxJava 中，Observable 代表的就是一个无限流对象。

我们再来看 BucketedCounterStream 的子类 BucketedRollingCounterStream 类，该类的构造函数中同样存在一个类似的方法，如下所示（为了避免过于复杂，裁剪了部分代码）。

```java
this.sourceStream = bucketedStream
	 //将N个Bucket进行汇总
	.window(numBuckets, 1)
	//汇总成一个窗口
	.flatMap(reduceWindowToSummary) 
     …
     //添加背压控制
	.onBackpressureDrop();
```

上述方法中基于父类 BucketedCounterStream 已经汇总的 bucketedStream 进行开窗处理，从而获取一个 sourceStream，这个 sourceStream 就是滑动窗口的最终形态。最后的 onBackpressureDrop() 语句是 RxJava 中提供的一种背压机制。我们在上一讲中讨论了背压机制的概念和作用，而在这里就看到了这一机制的具体应用。

作为总结，Hystrix 巧妙地运用了 RxJava 中的 window、flatMap 等操作符来将单位窗口时间内的事件，以及将一个窗口大小内的 Bucket 聚集到一起形成滑动窗口，并基于滑动窗口集成指标数据。这个设计思想非常巧妙，值得我们深入研究并对基于流的处理过程加以尝试和应用。

### Spring Cloud Gateway 中的过滤器

Spring Cloud Gateway 是 Spring Cloud 微服务开发框架中的另一个核心组件，是 Spring 官方自己开发的一款 API 网关。在技术体系上，Spring Cloud Gateway 基于最新的 Spring 5 和 Spring Boot 2，以及用于响应式编程的 Project Reactor 框架，提供的是响应式、非阻塞式 I/O 模型。所以性能上比 Netflix 中的 Zuul 网关要更胜一筹。

Spring Cloud Gateway 中的核心概念就是过滤器（Filter），围绕过滤器的请求处理流程如下图所示。

![](https://s0.lgstatic.com/i/image6/M00/24/07/Cgp9HWBYDj6AFo0eAACtCU1brX4578.png)

图 2 Spring Cloud Gateway 中的过滤器架构

过滤器用于在响应 HTTP 请求之前或之后修改请求本身及对应的响应结果。Spring Cloud Gateway 中提供了一个全局过滤器（GlobalFilter）的概念，对所有路由都生效。我们来演示一下如何使用全局过滤器来对所有 HTTP 请求进行拦截，具体做法是实现 GlobalFilter 接口，示例代码如下所示。

```java
@Configuration
public class JWTAuthFilter implements GlobalFilter {
 
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest.Builder builder = exchange.getRequest().mutate();
        builder.header("Authorization","Token");
        return chain.filter(exchange.mutate().request(builder.build()).build());
    }
}
```

以上代码展示了如何利用全局过滤器在所有的请求中添加 Header 的实现方法。在这个示例中，我们对所有经过 API 网关的 HTTP 请求添加了一个消息头，用来设置与访问 Token 相关的安全认证信息。

请注意，这里的 filter 方法返回了一个 Mono 对象，你可能会问这个 Mono 对象究竟是什么呢？事实上，这是在响应式编程框架 Project Reactor 中代表单个返回值的流式对象。我们将在“05 | 顶级框架：Spring 为什么选择 Reactor 作为响应式编程框架”对 Mono 对象进行详细的探讨。

我们再来看一个使用过滤器的场景。以下代码展示了一个用于处理响应的 PostGatewayFilter 的实现方式，其中首先继承一个 AbstractGatewayFilterFactory 类，然后可以通过覆写 apply 方法来提供针对 ServerHttpResponse 对象的任何操作。

```java
public class PostGatewayFilterFactory extends AbstractGatewayFilterFactory {
 
    public PostGatewayFilterFactory() {
        super(Config.class);
    }
 
    public GatewayFilter apply() {
        return apply(o -> {
        });
    }
 
    @Override
    public GatewayFilter apply(Config config) {
        return (exchange, chain) -> {
          return chain.filter(exchange).then(Mono.fromRunnable(() -> {
              ServerHttpResponse response = exchange.getResponse();

              //针对Response的各种处理
            }));
          };
    }
 
    public static class Config {
    }
}
```

同样，注意这里使用了 Reactor 框架中的 then 操作符，该操作符的含义是等到上一个操作完成再做下一个。所以，我们在过滤器链执行完对 exchange 对象的过滤之后，再通过 Mono.fromRunnable 方法创建一个新的线程，可以在这里添加各种针对 Response 对象的处理过程。

### Spring WebFlux 中的请求处理流程

Spring WebFlux 是 Spring 5 中引入的全新的响应式 Web 服务开发框架。针对涉及大量 I/O 操作的服务化架构，WebFlux 也是一种非常有效的解决方案，能够在复杂的流程中集成非阻塞、异步通信机制，从而实现高效处理跨服务之间的网络请求。

在 WebFlux 中，对 HTTP 请求的处理过程涉及了 HandlerMapping、HandlerAdapter、HandlerResultHandler 类之间的交互，整个流程如下图所示。

![](https://s0.lgstatic.com/i/image6/M00/24/04/CioPOWBYDjGAP5oHAADrAy1HQHE514.png)

图 3 WebFlux 处理 HTTP 请求的流程图

我们直接来看用于完成上图流程的 Handle 方法定义，该方法实现了流式处理请求机制，如下所示。

```java
public Mono<Void> handle(ServerWebExchange exchange) {
        if (this.handlerMappings == null) {
            return createNotFoundError();
        }
 
        return Flux.fromIterable(this.handlerMappings)
                //从handlerMapping这个map中获取HandlerMapping
                .concatMap(mapping -> mapping.getHandler(exchange))
                .next()
                //如果没有找到HandlerMapping，则抛出异常
                .switchIfEmpty(createNotFoundError())
                //触发HandlerAdapter的handle方法
                .flatMap(handler -> invokeHandler(exchange, handler))
                //触发HandlerResultHandler 的handleResult方法
                .flatMap(result -> handleResult(exchange, result));
}
```

在这个核心方法中，我们看到了 concatMap、switchIfEmpty 和 flatMap 等响应式操作符。其中的 flatMap 操作符我们在前面已经讨论过。关于这些操作符的具体使用方法，我同样会在第 7 讲为你详细介绍。



---------

# 如何基于Spring框架来学习响应式编程？

## Spring 5 中的响应式编程技术栈

Spring 5 引入了很多核心功能，这其中重要的就是全面拥抱了响应式编程的设计思想和实践。

Spring 5 的响应式编程模型以 Project Reactor 库为基础，而后者则实现了响应式流规范。事实上，Spring Boot 从 2.x 版本开始也是全面依赖 Spring 5。

针对响应式编程技术栈，有一点你需要注意，即响应式编程并不是只针对系统中的某一部分组件，而是需要适用于调用链路上的所有组件。无论是 Web 层、服务层还是处于下游的数据访问层，只要有一个环节不是响应式的，那么这个环节就会出现同步阻塞，从而导致 02 讲中所介绍的背压机制无法生效。这就是所谓的全栈式响应式编程的设计理念。

因此，Spring 5 也针对响应式编程构建了全栈式的开发组件。对于常见的应用程序而言，Web 服务层和数据访问层构成了最基本的请求链路。而 Spring 5 也提供了针对 Web 服务层开发的响应式 Web 框架 WebFlux，以及支持响应式数据访问的 Spring Data Reactive 框架。让我们一起来看一下。

### Spring WebFlux

在 Spring Boot 的基础上，我们将引入全新的 Spring WebFlux 框架。WebFlux 框架名称中的 Flux 一词就来源于 Project Reactor 框架中的 Flux 组件，我会在“06 | 流式操作：如何使用 Flux 和 Mono 高效构建响应式数据流”中对该组件和你展开详细的讨论。

WebFlux 功能非常强大，不仅包含了对创建和访问响应式 HTTP 端点的支持，还可以用来实现服务器推送事件以及 WebSocket。我们无意对该框架的所有功能做全面介绍，对于应用程序而言，开发人员的主要工作是基于 HTTP 协议的响应式服务的开发，这也是本课程内容的一大重点。

下图展示了 spring-boot-starter-webflux 2.2.4 RELEASE 版本的依赖组件，可以看到该版本在 spring-boot-starter 2.2.4 RELEASE 版本的基础上依赖于 spring-webflux 5.2.3.RELEASE 版本，而后者同样依赖 spring-web 5.2.3.RELEASE 版本以及 3.2.3.RELEASE 版本的 reactor-core 组件。

![](https://s0.lgstatic.com/i/image6/M01/21/3A/Cgp9HWBUIkiAV-sbAABUZLGbKGw167.png)

图 1 spring-boot-starter-webflux 的依赖组件

Spring WebFlux 提供了完整的支持响应式开发的服务端技术栈，Spring WebFlux 的整体架构如下图所示。

![](https://s0.lgstatic.com/i/image6/M01/21/37/CioPOWBUIk-ACq-RAACQeZA8Cyk312.png)

图 2 Spring WebFlux 架构图（来自 Spring 官网）

上图针对传统 spring-webmvc 技术栈和新型的 spring-webflux 技术栈做了一个对比。我们从上往下看，位于最上层所提供的实际上是面向开发人员的开发模式，注意左上部分两者存在一个交集，即 Spring WebFlux 既支持基于 @Controller、@RequestMapping 等注解的传统开发模式，又支持基于 Router Functions 的函数式开发模式。本课程后续内容将分别使用这两个模式来创建响应式 RESTful 服务。

关于框架背后的实现原理，传统的 Spring MVC 构建在 Java EE 的 Servlet 标准之上，该标准本身就是阻塞和同步的。在最新版本的 Servlet 中虽然也添加了异步支持，但是在等待请求的过程中，Servlet 仍然在线程池中保持着线程。而 Spring WebFlux 则是构建在响应式流以及它的实现框架 Reactor 的基础之上的一个开发框架，因此可以基于 HTTP 协议用来构建异步非阻塞的 Web 服务。

最后，我们来看一下位于底部的容器支持。显然，Spring MVC 是运行在传统的 Servlet 容器之上，而 Spring WebFlux 则需要支持异步的运行环境，比如 Netty、Undertow 以及 Servlet 3.1 版本以上的 Tomcat 和 Jetty，因为在 Servlet 3.1 中引入了异步 I/O 支持。

由于 WebFlux 提供了异步非阻塞的 I/O 特性，因此非常适合用来开发 I/O 密集型服务。而在使用 Spring MVC 就能满足的场景下，就不需要更改为 WebFlux。通常，我也不大建议你将 WebFlux 和 Spring MVC 混合使用，因为这种开发方式显然无法保证全栈式的响应式流。

### Spring Data Reactive

我们知道 Spring Data 是 Spring 家族中专门针对数据访问而开发的一个框架，针对各种数据存储媒介抽象了一批 Repository 接口以简化开发过程。而在 Spring Data 的基础上，Spring 5 也全面提供了一组响应式数据访问模型。

在介绍如何使用 Spring Data 实现响应式数据访问模型之前，我们再来看一下关于 Spring Boot 2 的另一张官网架构图，如下所示。

![](https://s0.lgstatic.com/i/image6/M01/21/3A/Cgp9HWBUIlmAPXzcAACWjgTTFkY994.png)

图 3 Spring Boot 2 架构图（来自 Spring 官网）

可以看到，上图底部明确把 Spring Data 划分为两大类型，一类是支持 JDBC、JPA 和部分 NoSQL 的传统 Spring Data Repository，而另一类则是支持 Mongo、Cassandra、Redis、Couchbase 等的响应式 Spring Data Reactive Repository。



## 案例驱动：ReactiveSpringCSS

介绍完 Spring 5 中所提供的响应式编程技术栈之后，我们将引出本课程的案例系统 ReactiveSpringCSS，这里的 CSS 是对客户服务系统 Customer Service System 的简称。客户服务是电商、健康类业务场景中非常常见的一种业务场景，我们将通过构建一个精简但又完整的系统来展示 Spring 5 中响应式编程相关的设计理念和各项技术组件。

现实场景下的客户服务业务逻辑一般都非常复杂，而案例系统的目的在于演示技术实现过程，不在于介绍具体业务逻辑。所以，我们对案例的业务流程做了高度的简化，但会包含 Spring 中所提供的各项响应式编程组件。

### ReactiveSpringCSS 整体架构

在 ReactiveSpringCSS 中，存在一个 customer-service，这是一个 Spring Boot 应用程序，也是整个案例系统中的主体服务。该服务将采用经典的分层架构，即将服务分成 Web 层、Service 层和 Repository 层。

我们知道在客服系统中，核心业务是生成客户工单。围绕客户工单的生成过程，ReactiveSpringCSS 的整个系统交互过程如下图所示。

![](https://s0.lgstatic.com/i/image6/M01/21/3A/Cgp9HWBUImGAJDTfAABpy3ZSzWs199.png)

图 4 ReactiveSpringCSS 系统的整体架构图

可以看到，customer-service 一般会与用户账户服务 account-service 进行交互以获取生成工单所需的用户账户信息，但因为用户账户信息的更新属于低频时间，所以我们设计的实现方式是 account-service 通过消息中间件的方式将用户账户变更信息主动推送给 customer-service，从而完成用户信息的获取操作。而针对 order-service，其定位是订单服务，customer-service 也需要从该服务中查询订单信息。

### ReactiveSpringCSS 响应式技术组件

在 ReactiveSpringCSS 的整体架构图中，引出了构建一个响应式系统所需的多项技术组件。

针对 Web 层，我们将使用 Spring WebFlux 组件来分别为 ReactiveSpringCSS 系统中的三个服务构建响应式 RESTful 端点，并通过支持响应式请求的 WebClient 客户端组件来消费这些端点。

在 Service 层，除了完成 Web 层和数据访问层的衔接作用之外，核心逻辑在于完成事件处理和消息通信相关的业务场景。account-service 充当了消息的发布者，而 customer-service 则是它的消费者。为了实现消息通信机制，就需要引入 Spring Cloud 家族中的 Spring Cloud Stream 组件。同样，在 Spring 5 中，也针对 Spring Cloud Stream 做了响应式升级，并提供了对应的响应式编程组件。

最后是 Repository 层，我们将引入 MongoDB 和 Redis 这两款支持响应式流的 NoSQL 数据库。其中 MongoDB 用于为各个服务存储业务数据，而 Redis 则主要用在 customer-service 中，我们把从 account-service 中传入的消息数据缓存在 Redis 中以便提升数据访问的性能。针对这两款 NoSQL，我们将分别引入 Spring 5 中的 Spring Data MongoDB Reactive 和 Spring Data Redis Reactive 进行整合。

当然，对于响应式编程全栈中的各个技术组件，都需要采用有效的测试手段确保其正确性。因此，我们将引入响应式测试组件分别针对响应式流、响应式 Web、响应式消息通信以及响应式数据访问进行全面的测试。

基于以上讨论，ReactiveSpringCSS 所采用的各项响应式编程技术及其应用方式如下图所示。

![](https://s0.lgstatic.com/i/image6/M01/21/3A/Cgp9HWBUImuAJdzJAADUPzZXTjQ358.png)

图 5 ReactiveSpringCSS 系统的响应式技术组件图

我将在后续的课程中对上图中的各个技术组件做专题介绍。





---

# Spring为什么选择Reactor作为响应式编程框架？

Reactor 是响应式领域中具有代表性的类库，实现了响应式流规范，同时已经成为 Spring 框架生态系统的重要组成部分。

今天这一讲，我们就先来分析响应式流的主流实现框架，并探讨 Reactor 中的基础组件。

## 响应式流的主流实现框架

在 Java 领域，目前响应式流的开发库包括 RxJava、Akka、Vert.x 和 Project Reactor 等。这里重点对 RxJava 和 Project Reactor 进行展开描述。

说起 RxJava，我们先来讨论它的前缀 Rx。这里的 Rx 代表的是响应式扩展 Reactive Extensions，实际上它最早诞生于微软的 .NET 平台，用来构建高性能的应用系统，其内部集成了异步数据序列的事件驱动编程。后来，Java 领域也充分借鉴了这一编程模型，诞生了 RxJava 框架，RxJava 可以说是响应式编程得以大规模应用的先驱，推动了一大批针对不同语言的响应式编程框架，这些编程框架同样都以 Rx 作为前缀，例如 RxSwift、RxRuby、RxGo，RxScale、RxKotlin 等。

RxJava 从最初的 1.x 发展到现在的 3.x 版本，各个版本之间变化较大。而从 2.x 版本开始，就对原有的 API 按照响应式流规范进行了重构，并提供了独立的背压功能。RxJava 应用广泛，例如，在 Netflix 的微服务套件中，熔断器 Hystrix、客户端负载均衡器 Ribbon、API 网关 Zuul 等常用组件中都使用到了 RxJava。除此之外，在以 Android 为代表的 UI 交互开发领域，RxJava 也普遍受到开发人员的欢迎。可以说，其他 Rx 开发库的兴起很大程度上归功于 RxJava 的发展。

聊完 RxJava，我们再来看 Reactor。相较于 RxJava，Reactor 诞生在响应式流规范制定之后，所以从一开始就是严格按照响应式流规范设计并实现了它的 API，这也是 Spring 选择它作为默认响应式编程框架的核心原因。

在发展过程中，Reactor 同样经历到从 1.X 到目前 3.X 的演进历程。Reactor 库自早期版本以来已经发展了很多，目前最新的 3.X 版本以 Java 8 作为基线，可以说已经成为业界最先进的响应式库。

RxJava 和 Reactor 二者对比来说，虽然 RxJava 诞生得更早，但 Reactor 应该更有前途。为什么这样说，因为它的开发更活跃，并得到了 Pivotal 公司的大力支持。从 API 角度看，这些库都非常相似，也都提供了一大批非常实用的操作符来简化开发过程。但既然 Spring 5 选择了 Reactor，就让我们来学习它吧。

## Project Reactor 框架

Reactor 框架可以单独使用。和集成其他第三方库一样，如果想要在代码中引入 Reactor，要做的事情就是在 Maven 的 pom 文件中添加如下依赖包。

```xml
<dependency>
    <groupId>io.projectreactor</groupId>
    <artifactId>reactor-core</artifactId>
</dependency>
	 
<dependency>
    <groupId>io.projectreactor</groupId>
    <artifactId>reactor-test</artifactId>
    <scope>test</scope>
</dependency>
```

其中 reactor-core 包含了 Reactor 的核心功能，而 reactor-test 则提供了支持测试的相关工具类。在本讲的后续内容中，我将从 Reactor 框架所提供的异步数据序列入手，引出该框架所提供的 Flux 和 Mono 这两个核心编程组件以及相关的操作符。最后，作为响应式流的核心，我们也会对它所具备的背压机制进行讨论。



### Reactor 异步数据序列

响应式流规范的基本组件是一个异步的数据序列，在 Reactor 框架中，我们可以把这个异步数据序列表示成如下形式。

![](https://s0.lgstatic.com/i/image6/M00/26/8D/CioPOWBbFBCAQDDNAACGnB65zn8934.png)

图 1 Reactor 框架异步序列模型

上图中的异步序列模型从语义上可以用如下公式表示。

```xml
onNext x 0..N [onError | onComplete]
```

显然，以上公式中包含了三种消息通知，分别对应在异步数据序列执行过程中的三种不同数据处理场景，其中：

- onNext 表示正常的包含元素的消息通知；
- onComplete 表示序列结束的消息通知；
- onError 表示序列出错的消息通知。

结合上一讲的内容，当触发这些消息通知时，异步序列的**订阅者中对应的这三个同名方法**将被调用。正常情况下，onNext() 和 onComplete() 方法都应该被调用，用来正常消费数据并结束序列。如果没有调用 onComplete() 方法就会生成一个无界数据序列，在业务系统中，这通常是不合理的。而 onError() 方法只有序列出现异常时才会被调用。

基于上述异步数据序列，Reactor 框架提供了两个核心组件来发布数据，分别是 Flux 和 Mono 组件。这两个组件可以说是应用程序开发过程中最基本的编程对象。



### Flux 和 Mono 组件

Flux 代表的是一个包含 0 到 n 个元素的异步序列，Reactor 官网给出了它的示意图，如下所示。

![](https://s0.lgstatic.com/i/image6/M00/26/91/Cgp9HWBbFCaAPHNNAAIMnXsm0_I218.png)

图 2 Flux 组件（来自 Reactor 官网）

上图中的“operator”代表的是操作符，红色的叉号代表异常，而最后的一个符号则代表序列正常结束。显然，序列的三种消息通知都适用于 Flux。在详细介绍 Flux的构建和使用方法之前，我们先通过一段简短的代码来演示使用 Flux 的方法，如下所示。

 

```java
private Flux<Account> getAccounts() {
        List<Account> accountList = new ArrayList<>();
 
        Account account = new Account();
        account.setId(1L);
        account.setAccountCode("DemoCode");
        account.setAccountName("DemoName");
        accountList.add(account);

        return Flux.fromIterable(accountList);
}
```

在以上代码中，我们通过 Flux.fromIterable() 方法构建了 Flux`<Account>` 对象并进行返回，Flux.fromIterable() 是构建 Flux 的一种常用方法，我会在下一讲和你进一步讨论。

我们再来看一个 Web 层组件的代码示例，如下所示。

```java
@GetMapping("/accounts")
public Flux<Account> getAccountList() {
        Flux<Account> accounts= accountService.getAccounts();
        return accounts;
}
```

在这个 Controller 提供的 "/accounts" 的端点中，我们调用了 Service 层方法返回了一个 Account 对象列表，它的数据类型也是 Flux`<Account>`。

介绍完 Flux 之后，我们再来看 Reactor 所提供的 Mono 组件。Mono 数据序列中只包含 0 个或 1 个元素，如下图所示。

![](https://s0.lgstatic.com/i/image6/M00/26/8D/CioPOWBbFDmAOLiVAAFp-asMTcw575.png)

图 3 Mono 组件（来自 Reactor 官网）

与 Flux 组件一样，我们同样通过一个服务层的方法来演示 Mono 组件的用法，示例代码如下。

```java
private Mono<Account> getAccountById(Long id) { 
        Account account = new Account();
        account.setId(id);
        account.setAccountCode("DemoCode");
        account.setAccountName("DemoName");
        accountList.add(account);

        return Mono.just(account);
}
```

可以看到，这里首先构建一个 Account 对象，然后通过 Mono.just() 方法返回一个 Mono 对象。Mono.just() 方法是构建 Mono 的最常见用法之一，我们同样在下一讲中会对其进一步介绍。

同样，Web 层组件获取 Mono`<Account>` 对象的示例端点如下所示。

```java
@GetMapping("/accounts/{id}")
public Mono<Account> getAccountById(@PathVariable Long id) {
    Mono<Account> account = accountService.getAccountById(id);

    return account;
}
```

显然，某种程度上可以把 Mono 看作是 Flux 的一种特例，而两者之间也可以进行相互的转换和融合。如果你有两个 Mono 对象，那么把它们合并起来就能获取一个 Flux 对象。除此之外，把一个 Flux 转换成 Mono 对象也有很多办法，例如对一个 Flux 对象中所包含的元素进行计数操作就能得到一个 Mono 对象。而这里合并和计数就是针对数据流的一种操作。Reactor 中提供了一大批非常实用的操作符来简化这些操作的开发过程。

### 操作符

操作符并不是响应式流规范的一部分，但为了改进响应式代码的可读性并降低开发成本，Reactor 库中的 API 提供了一组丰富的操作符，这些操作符为响应式流规范提供了最大的附加值。操作符的执行效果如下所示。

![](https://s0.lgstatic.com/i/image6/M00/26/8E/CioPOWBbFEmABfrGAADTAAE8mv4005.png)

图 4 Reactor 中操作符示意图

在 Reactor 中，可以把操作符分成转换、过滤、组合、条件、数学、日志、调试等几大类，每一类中都提供了一批有用的操作符。尤其是针对转换场景，操作符非常健全。在这个模块的接下来几讲中，我会详细介绍。

### 背压处理

背压是所有响应式编程框架所必须要考虑的核心机制，Reactor 框架支持所有常见的背压传播模式，包括以下几种。

- 纯推模式：这种模式下，订阅者通过 subscription.request(Long.MAX_VALUE) 请求有效无限数量的元素。
- 纯拉模式：这种模式下，订阅者通过 subscription.request(1) 方法在收到前一个元素后只请求下一个元素。
- 推-拉混合模式：这种模式下，当订阅者有实时控制需求时，发布者可以适应所提出的数据消费速度。

基于这些背压传播模式，在 Reactor 框架中，针对背压有以下四种处理策略。

- BUFFER：代表一种缓存策略，缓存消费者暂时还无法处理的数据并放到队列中（队列可以无限扩张），这时候使用的队列相当于是一种无界队列。
- DROP：代表一种丢弃策略，当消费者无法接收新的数据时丢弃这个元素，这时候相当于使用了有界丢弃队列。
- LATEST：类似于 DROP 策略，但让消费者只得到来自上游组件的最新数据。
- ERROR：代表一种错误处理策略，当消费者无法及时处理数据时发出一个错误信号。

Reactor 使用了一个枚举类型 OverflowStrategy 来定义这些背压处理策略，并提供了一组对应的 onBackpressureBuffer、onBackpressureDrop、onBackpressureLatest 和 onBackpressureError 操作符来设置背压，分别对应上述四种处理策略。

为了更好地展示操作符的语义和效果，从这一讲开始，我将引入弹珠图（Marble Diagram）。弹珠图能将数据流的转换以可视化方式呈现出来，它们对于描述操作符的行为非常有效，因此在 RxJava 或 Reactor 等响应式编程框架中，几乎所有的操作符都包含带有对应的弹珠图的说明。在我们课程的后续内容中也将大量使用弹珠图。实际上你在本讲前面的 Flux 和 Mono 组件中已经看到了弹珠图，而 Reactor 官网给出的 onBackpressureBuffer 操作符的弹珠图如下所示。

![](https://s0.lgstatic.com/i/image6/M00/26/91/Cgp9HWBbFFWAC8VCAANwlTGCS1U790.png)





-----

# 如何使用Flux和Mono高效构建响应式数据流？

Reactor 响应式编程框架实现了响应式流规范。我们知道在响应式流规范中，存在代表发布者的 Publisher 接口，而 Reactor 提供了这一接口的两种实现，即 Flux 和 Mono，它们是我们利用 Reactor 框架进行响应式编程的基础组件。

## 通过 Flux 对象创建响应式流

创建 Flux 的方式非常多，大体可以分成两大类，一类是基于各种工厂模式的静态创建方法，而另一类则采用编程的方式动态创建 Flux。相对而言，静态方法在使用上都比较简单，但不如动态方法来得灵活。

### 通过静态方法创建 Flux

Reactor 中静态创建 Flux 的方法常见的包括 just()、range()、interval() 以及各种以 `from-` 为前缀的方法等。同时，因为 Flux 可以代表 0 个数据，所以也有一些专门用于创建空序列的工具方法。

#### just() 方法

just() 方法可以指定序列中包含的全部元素，创建出来的 Flux 序列在发布这些元素之后会自动结束。一般情况下，在已知元素数量和内容时，使用 just() 方法是创建 Flux 的最简单直接的做法。使用 just() 方法创建 Flux 对象的示例代码如下所示。

```java
Flux.just("Hello", "World").subscribe(System.out::println);
```

不难想象，执行以上代码，我们将在系统控制台中得到如下结果，该结果与我们的预想完全一致。

```xml
Hello
World
```

这里我们对 Flux 执行了用于订阅的 subscribe() 方法，并通过使用 Lambda 表达式调用了 System.out.println() 方法，这意味着将结果打印到系统控制台。关于 subscribe() 方法以及对响应式流的订阅过程，我会在本讲后续内容中进一步说明。

#### fromXXX() 方法组

如果我们已经有了一个数组、一个 Iterable 对象或 Stream 对象，那么就可以通过 Flux 提供的 fromXXX() 方法组来从这些对象中自动创建 Flux，包括 fromArray()、fromIterable() 和 fromStream() 方法。

上一讲我们提到了 Flux.fromIterable() 方法，这里再给出一个使用 fromArray() 方法创建 Flux 对象的示例代码，如下所示。

```java
Flux.fromArray(new Integer[] {1, 2, 3})
	.subscribe(System.out::println);
```

这段代码的执行结果就是在控制台中输出三行记录。

```xml
1
2
3
```

#### range() 方法

如果你**快速生成一个整数数据流**，那么可以采用 range() 方法，该方法允许我们指定目标整数数据流的起始元素以及所包含的个数，序列中的所有对象类型都是 Integer，这在创建连续的年份信息或序号信息等场景下非常有用。使用 range() 方法创建 Flux 对象的示例代码如下所示。

```java
Flux.range(2020, 5).subscribe(System.out::println);
```

显然，这段代码会在控制台中打印出 5 行记录，从 2020 开始，到 2024 结束。

#### interval() 方法

在 Reactor 框架中，interval() 方法可以用来生成`从 0 开始递增的 Long 对象的数据序列`。通过 interval() 所具备的一组重载方法，我们可以分别指定这个数据序列中第一个元素发布之前的延迟时间，以及每个元素之间的时间间隔。interval() 方法相对复杂，我们先附上它的弹珠图，如下所示。

![图片9.png](https://s0.lgstatic.com/i/image6/M00/27/AE/Cgp9HWBdhB-ASNRVAAJo-Y1sCZw573.png)

使用 interval() 方法创建 Flux 示意图（来自 Reactor 官网）

可以看到，上图中每个元素发布时相当于添加了一个定时器的效果。使用 interval() 方法的示例代码如下所示。

```java
Flux.interval(Duration.ofSeconds(2), Duration.ofMillis(200)).subscribe(System.out::println);
```

这段代码的执行效果相当于在等待 2 秒钟之后，生成一个从 0 开始逐一递增的无界数据序列，每 200 毫秒推送一次数据。

#### empty()、error() 和 never()

根据上一讲介绍的 Reactor 异步序列的语义，我们可以分别使用 empty()、error() 和 never() 这三个方法类创建一些特殊的数据序列。其中，如果你希望创建一个只包含结束消息的空序列，那么可以使用 empty() 方法，使用示例如下所示。显然，这时候控制台应该没有任何的输出结果。

```java
Flux.empty().subscribe(System.out::println);
```

然后，通过 error() 方法可以创建一个只包含错误消息的序列。如果你不希望所创建的序列不发出任何类似的消息通知，也可以使用 never() 方法实现这一目标。当然，这几个方法都比较少用，通常只用于调试和测试。

不难看出，**静态创建 Flux 的方法简单直接，一般用于生成那些事先已经定义好的数据序列。而如果数据序列事先无法确定，或者生成过程中包含复杂的业务逻辑，那么就需要用到动态创建方法**。



### 通过动态方法创建 Flux

动态创建 Flux 所采用的就是以编程的方式创建数据序列，最常用的就是 generate() 方法和 create() 方法。

#### generate() 方法

generate() 方法生成 Flux 序列依赖于 Reactor 所提供的 SynchronousSink 组件，定义如下。

```java
public static <T> Flux<T> generate(Consumer<SynchronousSink<T>> generator)
```

SynchronousSink 组件包括 next()、complete() 和 error() 这三个核心方法。从 SynchronousSink 组件的命名上就能知道它是一个同步的 Sink 组件，也就是说元素的生成过程是同步执行的。这里要注意的是 next() 方法只能最多被调用一次。使用 generate() 方法创建 Flux 的示例代码如下。

```java
Flux.generate(sink -> {
    sink.next("Jianxiang");
    sink.complete();
}).subscribe(System.out::println);
```

运行该段代码，会在系统控制台上得到“Jianxiang”。我们在这里调用了一次 next() 方法，并通过 complete() 方法结束了这个数据流。如果不调用 complete() 方法，那么就会生成一个所有元素均为“Jianxiang”的无界数据流。

这个示例非常简单，但已经具备了动态创建一个 Flux 序列的能力。如果想要在序列生成过程中引入状态，那么可以使用如下所示的 generate() 方法重载。

```java
Flux.generate(() -> 1, (i, sink) -> {
            sink.next(i);
            if (i == 5) {
                sink.complete();
            }
            return ++i;
}).subscribe(System.out::println);
```

这里我们引入了一个代表中间状态的变量 i，然后根据 i 的值来判断是否终止序列。显然，以上代码的执行效果会在控制台中输入 1 到 5 这 5 个数字。

#### create()

create() 方法与 generate() 方法比较类似，但它使用的是一个 FluxSink 组件，定义如下。

```java
public static <T> Flux<T> create(Consumer<? super FluxSink<T>> emitter)
```

FluxSink 除了 next()、complete() 和 error() 这三个核心方法外，还定义了背压策略，并且可以在一次调用中产生多个元素。使用 create() 方法创建 Flux 的示例代码如下。

```java
Flux.create(sink -> {
            for (int i = 0; i < 5; i++) {
                sink.next("jianxiang" + i);
            }
            sink.complete();
}).subscribe(System.out::println);
```

运行该程序，我们会在系统控制台上得到从“jianxiang0”到“jianxiang4”的 5 个数据。通过 create() 方法创建 Flux 对象的方式非常灵活，在本专栏中会有多种场景用到这个方法。

以上就是通过Flux 对象创建响应式流的方法，此外，还可以通过 Mono 对象来创建响应式流，我们一起来看一下。



## 通过 Mono 对象创建响应式流

对于 Mono 而言，可以认为它是 Flux 的一种特例，所以很多创建 Flux 的方法同样适用。针对静态创建 Mono 的场景，前面给出的 just()、empty()、error() 和 never() 等方法同样适用。除了这些方法之外，比较常用的还有 justOrEmpty() 等方法。

justOrEmpty() 方法会先判断所传入的对象中是否包含值，只有在传入对象不为空时，Mono 序列才生成对应的元素，该方法示例代码如下。

```java
Mono.justOrEmpty(Optional.of("jianxiang"))
	.subscribe(System.out::println);
```

另一方面，如果要想动态创建 Mono，我们同样也可以通过 create() 方法并使用 MonoSink 组件，示例代码如下。

```java
Mono.create(sink ->
sink.success("jianxiang")).subscribe(System.out::println);
```

## 订阅响应式流

介绍完如何创建响应式流，接下来就需要讨论如何订阅响应式流。想要订阅响应式流，就需要用到 subscribe() 方法。在前面的示例中我们已经演示了 subscribe 操作符的用法，知道可以通过 subscribe() 方法来添加相应的订阅逻辑。同时，在调用 subscribe() 方法时可以指定需要处理的消息通知类型。正如前面内容所看到的，Flux 和 Mono 提供了一批非常有用的 subscribe() 方法重载方法，大大简化了订阅的开发例程。这些重载方法包括如下几种。

```java
//订阅流的最简单方法，忽略所有消息通知
subscribe();
 
//对每个来自 onNext 通知的值调用 dataConsumer，但不处理 onError 和 onComplete 通知
subscribe(Consumer<T> dataConsumer);
 
//在前一个重载方法的基础上添加对 onError 通知的处理
subscribe(Consumer<T> dataConsumer, Consumer<Throwable> errorConsumer);
 
//在前一个重载方法的基础上添加对 onComplete 通知的处理
subscribe(Consumer<T> dataConsumer, Consumer<Throwable> errorConsumer,
Runnable completeConsumer);
 
//这种重载方法允许通过请求足够数量的数据来控制订阅过程
subscribe(Consumer<T> dataConsumer, Consumer<Throwable> errorConsumer,
Runnable completeConsumer, Consumer<Subscription> subscriptionConsumer);
 
//订阅序列的最通用方式，可以为我们的 Subscriber 实现提供所需的任意行为
subscribe(Subscriber<T> subscriber);
```

Reactor 中的消息通知类型有三种，即正常消息、错误消息和完成消息。显然，通过上述 subscribe() 重载方法，我们可以只处理其中包含的正常消息，也可以同时处理错误消息和完成消息。例如，下面这段代码示例展示了同时处理正常和错误消息的实现方法。

```java
Mono.just(“AAA”)
         .concatWith(Mono.error(new IllegalStateException()))
         .subscribe(System.out::println, System.err::println);
```

以上代码的执行结果如下所示，我们得到了一个“AAA”，同时也获取了 IllegalStateException 这个异常。

```java
AAA
java.lang.IllegalStateException
```

有时候我们不想直接抛出异常，而是希望采用一种容错策略来返回一个默认值，就可以采用如下方式。

```java
Mono.just(“jianxiang”)
          .concatWith(Mono.error(new IllegalStateException()))
          .onErrorReturn(“default”)
          .subscribe(System.out::println);
```

以上代码的执行结果如下所示，当产生异常时我们使用 onErrorReturn() 方法返回一个默认值“default”。

```java
jianxiang 
default
```

另外一种容错策略是通过 switchOnError() 方法使用另外的流来产生发生异常后返回的元素，以下代码演示了这种策略，执行结果与上面的示例一致。

```java
Mono.just(“jianxiang”)
         .concatWith(Mono.error(new IllegalStateException()))
         .switchOnError(Mono.just(“default”))
         .subscribe(System.out::println);
```

我们可以充分利用 Lambda 表达式来使用 subscribe() 方法，例如下面这段代码。

```java
Flux.just("jianxiang1", "jianxiang2", "jianxiang3")
    .subscribe(
    	data -> System.out.println("onNext:" + data), 
    	err -> {}, 
    	() -> System.out.println("onComplete")
	);
```

这段代码的执行效果如下所示，可以看到，我们分别对 onNext 通知和 onComplete 通知进行了处理。

```xml
onNext:jianxiang1
onNext:jianxiang2
onNext:jianxiang3
onComplete
```



# Reactor操作符（上）：如何快速转换响应式流？

前面我们介绍了 Reactor 框架中创建 Flux 和 Mono 这两种数据流的各种方法。一旦我们得到了一个数据流，就可以使用它来完成某个特定的需求。

和其他主流的响应式编程框架一样，Reactor 框架的设计目标也是为了简化响应式流的使用方法。为此，Reactor 框架为我们提供了大量操作符，用于操作 Flux 和 Mono 对象。



## 操作符的分类

在进行响应式编程时，灵活应用操作符是开发人员的核心工作。由于 Reactor 中所提供的操作符数量众多，本课程不打算对所有这些操作符进行全面而细致的介绍，而是尝试将操作符进行分类，然后对每一类中具有代表性的操作符展开讨论。

业界关于响应式操作符的分类并没有统一的说法，但针对数据流通常都会涉及转换、过滤、裁剪等核心操作，以及一些辅助性的操作。因此，本课程中我将 Flux 和 Mono 操作符分成如下六大类型：

- 转换（Transforming）操作符，负责将序列中的元素转变成另一种元素；
- 过滤（Filtering）操作符，负责将不需要的数据从序列中剔除出去；
- 组合（Combining）操作符，负责将序列中的元素进行合并、连接和集成；
- 条件（Conditional）操作符，负责根据特定条件对序列中的元素进行处理；
- 裁剪（Reducing）操作符，负责对序列中的元素执行各种自定义的裁剪操作；
- 工具（Utility）操作符，负责一些针对流式处理的辅助性操作。

其中，我把前面三种操作符统称为“转换类”操作符，剩余的三大类统称为“裁剪类”操作符。这一讲先来针对“转换类”的常见操作符做具体展开，“裁剪类”的操作符将放在下一讲中介绍。

## 转换操作符

转换可以说是对数据流最常见的一种操作了，Reactor 中常用的转换操作符包括 buffer、window、map 和 flatMap 等。

### buffer 操作符

buffer 操作符的作用相当于把当前流中的元素统一收集到一个集合中，并把这个集合对象作为新的数据流。使用 buffer 操作符在进行元素收集时，可以指定集合对象所包含的元素的最大数量。buffer 操作符的一种用法如下所示。

```java
Flux.range(1, 25).buffer(10).subscribe(System.out::println);
```

以上代码先使用上一讲中介绍的 range() 方法创建 1~25 这 25 个元素，然后演示了通过 buffer 操作符从包含这 25 个元素的流中构建一组集合，每个集合包含 10 个元素，所以一共构建 3 个集合。显然，上面这段代码的执行效果如下所示。

```xml
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
[11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
[21, 22, 23, 24, 25]
```

buffer 操作符的另一种用法是指定收集的时间间隔，由此演变出了一组 bufferTimeout() 方法，bufferTimeout() 方法可以指定时间间隔为一个 Duration 对象或毫秒数。

### window 操作符

window 操作符的作用类似于 buffer，不同的是 window 操作符是把当前流中的元素收集到另外的 Flux 序列中，而不是一个集合。因此该操作符的返回值类型就变成了 `Flux<Flux>`。window 操作符相对比较复杂，我们附上官方给出的弹珠图，如下所示。

![Drawing 1.png](https://s0.lgstatic.com/i/image6/M00/29/9C/Cgp9HWBhfxqAbRiUAAQFjAhjF5U321.png)

window 操作符示意图（来自 Reactor 官网）

上图比较复杂，代表的是一种对序列进行开窗的操作。我们还是通过一个简单的示例来进一步阐述 window 操作符的作用，示例代码如下。

```java
Flux<Flux<Integer>> fluxFlux = Flux.range(1, 5).window(2);
for (Flux<Integer> integerFlux : fluxFlux.toIterable()) {
    integerFlux.subscribe(System.out::println);
    System.out.println("---------");
}
```

这里我们生成了 5 个元素，然后通过 window 操作符把这 5 个元素转变成 3 个 Flux 对象。在将这些 Flux 对象转化为 Iterable 对象后，通过 forEach() 循环打印出来，执行效果如下所示。

```xml
1
2
-------
3
4
-------
5
```

### map 操作符

map 操作符相当于一种映射操作，它对流中的每个元素应用一个映射函数从而达到转换效果，比较简单，你可以来看一下示例。

```java
Flux.just(1, 2).map(i -> "number-" + i).subscribe(System.out::println);
```

显然，这行代码的输入应该是这样：

```xml
number-1
number-2
```

### flatMap 操作符

flatMap 操作符执行的也是一种映射操作，但与 map 不同，该操作符会把流中的每个元素映射成一个流而不是一个元素，然后再把得到的所有流中的元素进行合并，整个过程你可以通过 flapMap 操作符的弹珠图进行理解，如下所示。

![Drawing 3.png](https://s0.lgstatic.com/i/image6/M00/29/A5/CioPOWBhfyaAdHDOAALuJxPlC4w200.png)

flapMap 操作符示意图（来自 Reactor 官网）

上图比较复杂，而如下代码展示了 flatMap 操作符的一种常见的应用方法。

```java
Flux.just(1, 5)
     .flatMap(x -> Mono.just(x * x))
     .subscribe(System.out::println);
```

以上代码中，我们对 1 和 5 这两个元素使用了 flatMap 操作，操作的结果是返回它们的平方值并进行合并，执行效果如下。

```xml
1
25
```

事实上，flatMap 可以对任何你感兴趣的操作进行转换。例如，在系统开发过程中，我们经常会碰到对从数据库查询所获取的数据项逐一进行处理的场景，这时候就可以充分利用 flatMap 操作符的特性开展相关操作。

如下所示的代码演示了针对从数据库获取的 User 数据，如何使用该操作符逐一查询 User 所生成的订单信息的实现方法。

```java
Flux<User> users = userRepository.getUsers();
users.flatMap(u -> getOrdersByUser(u))
```

flatMap 操作符非常强大而实用，在本课程的案例中，你会经常看到 flatMap 的这种使用方法。

以上就是常见的四种转换操作符，我通过文字描述以及代码演示，让你对此形成一定的认知，为后续的学习打下基础。下面再来说说过滤操作符。

## 过滤操作符

过滤类操作符的作用非常明确，就是从数据流中只获取自己想要的元素。Reactor 中的过滤操作符也有很多，常用的包括 filter、first/last、skip/skipLast、take/takeLast 等，这些操作符应用起来都相对比较简单。

### filter 操作符

filter 操作符的含义与普通的过滤器类似，就是对流中包含的元素进行过滤，只留下满足指定过滤条件的元素，而过滤条件的指定一般是通过断言。

例如，我们想要对 1~10 这 10 个元素进行过滤，只获取能被 2 取余的元素，可以使用如下代码。

```java
Flux.range(1, 10).filter(i -> i % 2 == 0)
	.subscribe(System.out::println);
```

这里的“i % 2 == 0”代表的就是一种断言。

### first/last 操作符

first 操作符的执行效果为返回流中的第一个元素，而 last 操作符的执行效果即返回流中的最后一个元素。这两个操作符很简单，但却很常用。不需要给出代码示例相信你也能明白它们的用法。

### skip/skipLast

如果使用 skip 操作符，将会忽略数据流的前 n 个元素。类似的，如果使用 skipLast 操作符，将会忽略流的最后 n 个元素。

### take/takeLast

take 系列操作符用来从当前流中提取元素。我们可以按照指定的数量来提取元素，也可以按照指定的时间间隔来提取元素。类似的，takeLast 系列操作符用来从当前流的尾部提取元素。

take 和 takeLast 操作符的示例代码如下，我们不难得出它们的执行效果分别为返回 1 到 10，以及返回 991 到 1000 的 10 个数字。

```java
//取前10个
Flux.range(1,100).take(10).subscribe(System.out::println);

//取后10个
Flux.range(1,100).takeLast(10).subscribe(System.out::println);
```

以上就是过滤操作符，下面再来说说组合操作符。

## 组合操作符

Reactor 中常用的组合操作符有 then/when、merge、startWith 和 zip 等。相比过滤操作符，组合操作符要复杂一点，我们先从简单的看起。

### then/when 操作符

then 操作符的含义是等到上一个操作完成再进行下一个。以下代码展示了该操作符的用法。

```java
Flux.just(1, 2, 3)
    .then()
    .subscribe(System.out::println);
```

这里尽管生成了一个包含 1、2、3 三个元素的 Flux 流，但 then 操作符在上游的元素执行完成之后才会触发新的数据流，也就是说会忽略所传入的元素，所以上述代码在控制台上实际并没有任何输出。

和 then 一起的还有一个 thenMany 操作服务，具有同样的含义，但可以初始化一个新的 Flux 流。示例代码如下所示，这次我们会看到控制台上输出了 4 和 5 这两个元素。

```java
Flux.just(1, 2, 3)
    .thenMany(Flux.just(4, 5))
    .subscribe(System.out::println);
```

对应的，when 操作符的含义则是等到多个操作一起完成。如下代码很好地展示了 when 操作符的实际应用场景。

```java
public Mono<Void> updateOrders(Flux<Order> orders) {
        return orders
            .flatMap(file -> {
                Mono<Void> saveOrderToDatabase = ...;
                
                Mono<Void> sendMessage = ...;
 
                return Mono.when(saveOrderToDatabase, 
	sendMessage);
       });
}
```

------

在上述代码中，假设我们对订单列表进行批量更新，首先把订单数据持久化到数据库，然后再发送一条通知类的消息。我们需要确保这两个操作都完成之后方法才能返回，所以用到了 when 操作符。

### merge 操作符

作为一种典型的组合类操作符，merge 操作符用来把多个 Flux 流合并成一个 Flux 序列，而合并的规则就是按照流中元素的实际生成的顺序进行，它的弹珠图如下所示。

![Drawing 5.png](https://s0.lgstatic.com/i/image6/M00/29/9C/Cgp9HWBhfz6ABVQNAANJ8ZXLXC8786.png)

merge 操作符示意图（来自 Reactor 官网）

merge 操作符的代码示例如下所示，我们通过 Flux.intervalMillis() 方法分别创建了两个 Flux 序列，然后将它们 merge 之后打印出来。

```java
Flux.merge(Flux.intervalMillis(0, 100).take(2), Flux.intervalMillis(50, 100).take(2)).toStream()
                .forEach(System.out::println);
```

请注意，这里的第一个 intervalMillis 方法没有延迟，每隔 100 毫秒生成一个元素，而第二个 intervalMillis 方法则是延迟 50 毫秒之后才发送第一个元素，时间间隔同样是 100 毫秒。相当于两个数据序列会交错地生成数据，并合并在一起。所以以上代码的执行效果如下所示。

```xml
0
0
1
1
```

和 merge 类似的还有一个 mergeSequential 方法。不同于 merge 操作符，mergeSequential 操作符则按照所有流被订阅的顺序，以流为单位进行合并。现在我们来看一下这段代码，这里仅仅将 merge 操作换成了 mergeSequential 操作。

```java
Flux.mergeSequential (Flux.intervalMillis(0, 100).take(2), Flux.intervalMillis(50, 100).take(2)).toStream()
                .forEach(System.out::println);
```

执行以上代码，我们将得到不同的结果，如下所示。

```xml
0
1
0
1
```

显然从结果来看，mergeSequential 操作是等上一个流结束之后再 merge 新生成的流元素。

### zip 操作符

zip 操作符的合并规则比较特别，是将当前流中的元素与另外一个流中的元素按照一对一的方式进行合并，如下所示。

![Drawing 7.png](https://s0.lgstatic.com/i/image6/M00/29/A5/CioPOWBhf0-AMFkrAAMs-TKDoUM878.png)

zip 操作符示意图（来自 Reactor 官网）

使用 zip 操作符在合并时可以不做任何处理，由此得到的是一个元素类型为 Tuple2 的流，示例代码如下所示。

```java
Flux flux1 = Flux.just(1, 2);
Flux flux2 = Flux.just(3, 4);
Flux.zip(flux1, flux2).subscribe(System.out::println);
```

以上代码执行效果如下所示。

```xml
[1,3]
[2,4]
```

我们可以使用 zipWith 操作符实现同样的效果，示例代码如下所示。

```java
Flux.just(1, 2).zipWith(Flux.just(3, 4))
	.subscribe(System.out::println);
```

另一方面，我们也可以通过自定义一个 BiFunction 函数来对合并过程做精细化的处理，这时候所得到的流的元素类型即为该函数的返回值类似，示例代码如下所示。

```java
Flux.just(1, 2).zipWith(Flux.just(3, 4), (s1, s2) -> 
	String.format("%s+%s=%s", s1, s2, s1 + s2))
	.subscribe(System.out::println);
```

以上代码执行效果如下，可以看到我们对输出内容做了自定义的格式化操作。

```xml
1+3=4
2+4=6
```





# Reactor操作符（下）：如何多样化裁剪响应式流？

通过前两讲的内容可以知道，Reactor 框架为我们提供了各种操作符，使用这些操作符可以高效地操作 Flux 和 Mono 对象。Reactor 中的操作符可以分成不同的类型，上一讲我们关注转换、过滤和组合类的操作符，而今天我将继续为你介绍剩余的条件、裁剪、工具类的操作符。

### 条件操作符

所谓条件操作符，本质上就是提供了一个判断的依据来确定是否处理流中的元素。Reactor 中常用的条件操作符有 defaultIfEmpty、takeUntil、takeWhile、skipUntil 和 skipWhile 等，下面我将分别介绍。

#### defaultIfEmpty 操作符

defaultIfEmpty 操作符针对空数据流提供了一个简单而有用的处理方法。该操作符用来返回来自原始数据流的元素，如果原始数据流中没有元素，则返回一个默认元素。

defaultIfEmpty 操作符在实际开发过程中应用广泛，通常用在对方法返回值的处理上。如下所示的就是在 Controller 层中对 Service 层返回结果的一种常见处理方法。

```java
@GetMapping("/orders/{id}")
public Mono<ResponseEntity<Order>> findOrderById(@PathVariable 
	String id) {
     return orderService.findOrderById(id)
         .map(ResponseEntity::ok)
         .defaultIfEmpty(ResponseEntity
	.status(404).body(null));
}
```

可以看到，这里使用 defaultIfEmpty 操作符实现默认返回值。在示例代码所展示的 HTTP 端点中，当找不到指定的数据时，我们可以通过 defaultIfEmpty 方法返回一个空对象以及 404 状态码。

#### takeUntil/takeWhile 操作符

takeUntil 操作符的基本用法是 takeUntil (Predicate<? super T> predicate)，其中 Predicate 代表一种断言条件，该操作符将从数据流中提取元素直到断言条件返回 true。takeUntil 的示例代码如下所示，我们希望从一个包含 100 个连续元素的序列中获取 1~10 个元素。

```java
Flux.range(1, 100).takeUntil(i -> i == 10)
	.subscribe(System.out::println);
```

类似的，takeWhile 操作符的基本用法是 takeWhile (Predicate<? super T> continuePredicate)，其中 continuePredicate 代表的也是一种断言条件。与 takeUntil 不同的是，takeWhile 会在 continuePredicate 条件返回 true 时才进行元素的提取。takeWhile 的示例代码如下所示，这段代码的执行效果与 takeUntil 的示例代码一致。

```java
Flux.range(1, 100).takeWhile(i -> i <= 10)
	.subscribe(System.out::println);
```

讲到这里，让我们回顾上一讲介绍的第一个转换操作符 buffer。事实上，Reactor 框架中同样也提供了 bufferUntil 和 bufferWhile 操作符来实现数据收集，这两个操作符用到了和 takeUntil/takeWhile 完全一样的断言机制，如下代码演示了 bufferUntil 的使用方法。

```java
Flux.range(1, 10).bufferUntil(i -> i % 2 == 0)
	.subscribe(System.out::println);
```

以上代码的执行结果如下所示，这里所设置的断言就是“i % 2 == 0”这一条件。

```xml
[1, 2]
[3, 4]
[5, 6]
[7, 8]
[9, 10]
```

对应的，bufferWhile 的使用方法和执行结果分别如下所示。

```java
Flux.range(1, 10).bufferWhile(i -> i % 2 == 0)
	.subscribe(System.out::println);
[2]
[4]
[6]
[8]
[10]
```

#### skipUntil/skipWhile 操作符

与 takeUntil 相对应，skipUntil 操作符的基本用法是 skipUntil (Predicate<? super T> predicate)。skipUntil 将丢弃原始数据流中的元素直到 Predicate 返回 true。

同样，与 takeWhile 相对应，skipWhile 操作符的基本用法是 skipWhile (Predicate<? super T> continuePredicate)，当 continuePredicate 返回 true 时才进行元素的丢弃。这两个操作符都很简单，就不具体展开讨论了。

下面来说说裁剪操作符。

### 裁剪操作符

裁剪操作符通常用于统计流中的元素数量，或者检查元素是否具有一定的属性。在 Reactor 中，常用的裁剪操作符有 any 、concat、count 和 reduce 等。

#### any 操作符

any 操作符用于检查是否至少有一个元素具有所指定的属性，示例代码如下。

```java
Flux.just(3, 5, 7, 9, 11, 15, 16, 17)
        .any(e -> e % 2 == 0)
        .subscribe(isExisted -> System.out.println(isExisted));
```

在这个 Flux 流中存在一个元素 16 可以被 2 除尽，所以控制台将输出“true”。

类似的，Reactor 中还存在一个 all 操作符，用来检查流中元素是否都满足同一属性，示例代码如下所示。

```java
Flux.just("abc", "ela", "ade", "pqa", "kang")
        .all(a -> a.contains("a"))
        .subscribe(isAllContained -> System.out.println(isAllContained));
```

显然，在这个 Flux 流中所有元素都包含了字符“a”，所以控制台也将输出“true”。

#### concat 操作符

concat 操作符用来合并来自不同 Flux 的数据。与上一讲中所介绍的 merge 操作符不同，这种合并采用的是顺序的方式，所以严格意义上并不是一种合并操作，所以我们把它归到裁剪操作符类别中。

例如，如果执行下面这段代码，我们将在控制台中依次看到 1 到 10 这 10 个数字。

```java
Flux.concat(
            Flux.range(1, 3),
            Flux.range(4, 2),
            Flux.range(6, 5)
        ).subscribe(System.out::println);
};
```

#### reduce 操作符

裁剪操作符中最经典的就是这个 reduce 操作符。reduce 操作符对来自 Flux 序列中的所有元素进行累积操作并得到一个 Mono 序列，该 Mono 序列中包含了最终的计算结果。reduce 操作符示意图如下所示。

![Drawing 1.png](https://s0.lgstatic.com/i/image6/M00/2C/98/CioPOWBlYDaAMg1pAAPcwZ2XS_I628.png)

reduce 操作符示意图（来自 Reactor 官网）

在上图中，具体的累积计算很简单，我们也可以通过一个 BiFunction 来实现任何自定义的复杂计算逻辑。reduce 操作符的示例代码如下所示，这里的 BiFunction 就是一个求和函数，用来对 1 到 10 的数字进行求和，运行结果为 55。

```java
Flux.range(1, 10).reduce((x, y) -> x + y)
	.subscribe(System.out::println);
```

与 reduce 操作符类似的还有一个 reduceWith 操作符，用来在 reduce 操作时指定一个初始值。reduceWith 操作符的代码示例如下所示，我们使用 5 来初始化求和过程，显然得到的结果将是 60。

```java
Flux.range(1, 10).reduceWith(() -> 5, (x, y) -> x + y)
	.subscribe(System.out::println);
```

以上就是三种裁剪操作符的介绍，应该很好理解，下面我们来看看工具操作符。

### 工具操作符

Reactor 中常用的工具操作符有 subscribe、timeout、block、log 和 debug 等。

#### subscribe 操作符

说起 subscribe 操作符，我已经在“06 | 流式操作：如何使用 Flux 和 Mono 高效构建响应式数据流”中讲到订阅响应式流时介绍过很多，这里再带你回顾一下通过该操作符订阅序列的最通用方式，如下所示。

```java
//订阅序列的最通用方式，可以为我们的Subscriber实现提供所需的任意行为
subscribe(Subscriber<T> subscriber);
```

基于这种方式，如果默认的 subscribe() 方法没有提供所需的功能，我们可以实现自己的 Subscriber。一般而言，我们总是可以直接实现响应式流规范所提供的 Subscriber 接口，并将其订阅到流。实现一个自定义的 Subscriber 并没有想象中那么困难，这里我给你演示一个简单的实现示例。

```java
Subscriber<String> subscriber = new Subscriber<String>() {
            volatile Subscription subscription; 

            public void onSubscribe(Subscription s) {
                subscription = s;
                System.out.println("initialization");
                subscription.request(1);
            }

            public void onNext(String s) {
                System.out.println("onNext:" + s);
                subscription.request(1);
            }

            public void onComplete() { 
                System.out.println("onComplete");
            }

            public void onError(Throwable t) { 
                System.out.println("onError:" + t.getMessage());
            }
};
```

在这个自定义 Subscriber 实现中，我们首先持有对订阅令牌 Subscription 的引用。由于订阅和数据处理可能发生在不同的线程中，因此我们使用 volatile 关键字来确保所有线程都具有对 Subscription 实例的正确引用。

当订阅到达时，我们会通过 onSubscribe 回调通知 Subscriber。在这里，我们保存订阅令牌并初始化请求。

你应该注意到，在 onNext 回调中，我们打印接收到的数据并请求下一个元素。在这种情况下，我们执行 subscription.request(1) 方法，也就是说使用简单的拉模型来管理背压。

剩下的 onComplete 和 onError 方法我们都只是打印了一下日志。

现在，让我们通过 subscribe() 方法来使用这个 Subscriber，如下所示。

```java
Flux<String> flux = Flux.just("12", "23", "34");
        flux.subscribe(subscriber);
```

上述代码应该产生以下控制台输出的结果。

```xml
initialization
onNext:12
onNext:23
onNext:34
onComplete
```

前面构建的自定义 Subscriber 虽然能够正常运作，但因为过于偏底层，因此并不推荐你使用。我们推荐的方法是扩展 Project Reactor 提供的 BaseSubscriber 类。在这种情况下，订阅者可能如下所示。

```java
class MySubscriber<T> extends BaseSubscriber<T> {
            public void hookOnSubscribe(Subscription subscription) {
                System.out.println("initialization");
                request(1);
            }
 
            public void hookOnNext(T value) {
                System.out.println("onNext:" + value);
                request(1);
            }
}
```

可以看到这里使用了两个钩子方法：hookOnSubscribe(Subscription) 和 hookOnNext(T)。和这两个方法一起，我们可以重载诸如 hookOnError(Throwable)、hookOnCancel()、hookOnComplete() 等方法。

#### timeout 操作符

timeout 操作符非常简单，保持原始的流发布者，当特定时间段内没有产生任何事件时，将生成一个异常。

#### block 操作符

顾名思义，block 操作符在接收到下一个元素之前会一直阻塞。block 操作符常用来把响应式数据流转换为传统数据流。例如，使用如下方法将分别把 Flux 数据流和 Mono 数据流转变成普通的 List`<Order>` 对象和单个的 Order 对象，我们同样可以设置 block 操作的等待时间。

```java
public List<Order> getAllOrders() {
        return orderservice.getAllOrders()
	.block(Duration.ofSecond(5));
}
 
public Order getOrderById(Long orderId) {
  return orderservice.getOrderById(orderId)
	.block(Duration.ofSecond(2));
}
```

#### log 操作符

Reactor 中专门提供了针对日志的工具操作符 log，它会观察所有的数据并使用日志工具进行跟踪。我们可以通过如下代码演示 log 操作符的使用方法，在 Flux.just() 方法后直接添加 log() 函数。

```java
Flux.just(1, 2).log().subscribe(System.out::println);
```

以上代码的执行结果如下所示（为了显示简洁，部分内容和格式做了调整）。通常，我们也可以在 log() 方法中添加参数来指定日志分类的名称。

```xml
Info: | onSubscribe([Synchronous Fuseable] FluxArray.ArraySubscription)
Info: | request(unbounded)
Info: | onNext(1)
1
Info: | onNext(2)
2
Info: | onComplete()
```

#### debug 操作符

在“01 | 追本溯源：响应式编程究竟是一种什么样的技术体系”中，我们已经提到基于回调和异步的实现方式比较难以调整。响应式编程也是一样，这也是它与传统编程方式之间一个很大的差异点。

为此，Reactor 框架的设计者也考虑到了普通开发人员的诉求，并开发了专门用于 debug 的操作符。要想启动调试模式，我们需要在程序开始的地方添加如下代码。

```java
Hooks.onOperator(providedHook -> 
	providedHook.operatorStacktrace())
```

现在，所有的操作符在执行时都会保存与执行过程相关的附加信息。而当系统出现异常时，这些附加信息就相当于系统异常堆栈信息的一部分，方便开发人员进行问题的分析和排查。

上述做法是全局性的，如果你只想观察某个特定的流，那么就可以使用检查点（checkpoint）这一调试功能。例如以下代码演示了如何通过检查点来捕获 0 被用作除数的场景，我们在代码中添加了一个名为“debug”的检查点。

```java
Mono.just(0).map(x -> 1 / x)
	.checkpoint("debug").subscribe(System.out::println);
```

以上代码的执行结果如下所示。

```java
Exception in thread "main" reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.ArithmeticException: / by zero
	Caused by: java.lang.ArithmeticException: / by zero
	…
 
Assembly trace from producer [reactor.core.publisher.MonoMap] :
    reactor.core.publisher.Mono.map(Mono.java:2029)
    com.jianxiang.reactor.demo.Debug.main(Debug.java:10)
Error has been observed by the following operator(s):
    |_  Mono.map(Debug.java:10)
    |_  Mono.checkpoint(Debug.java:10)
 
    Suppressed: reactor.core.publisher.FluxOnAssembly$AssemblySnapshotException: zero
        at reactor.core.publisher.MonoOnAssembly.<init>(MonoOnAssembly.java:55)
        at reactor.core.publisher.Mono.checkpoint(Mono.java:1304)
        ... 1 more
```

可以看到，这个检查点信息会包含在异常堆栈中。根据需要在系统的关键位置上添加自定义的检查点，也是我们日常开发过程中的一种最佳实践。





---

# 框架升级：WebFlux比WebMVC到底好在哪里？

从这一讲开始，我们将进入实际应用阶段，即围绕一个典型的多层架构，从每一层出发构建响应式应用程序。

首先关注的是 Web 服务层。在构建响应式 Web 服务上，Spring 5 中引入了全新的编程框架，那就是 Spring WebFlux。作为一款新型的 Web 服务开发框架，它与传统的 WebMVC 相比具体有哪些优势呢？

## Spring WebFlux 的应用场景

WebFlux 用于构建响应式 Web 服务。在详细介绍 WebFlux 之前，我们先梳理一下这个新框架的应用场景，了解应用场景才能帮助我们对所要采用的技术体系做出正确的选择。

像 Reactor 这样的响应式库可以帮助我们构建一个`异步的非阻塞流`，并且为开发人员屏蔽了底层的技术复杂度。而基于 Reactor 框架的 WebFlux 进一步降低了开发响应式 Web 服务的难度。

微服务架构的兴起为 WebFlux 的应用提供了一个很好的场景。我们知道在一个微服务系统中，存在数十乃至数百个独立的微服务，它们相互通信以完成复杂的业务流程。这个过程势必会涉及大量的 I/O 操作，尤其是阻塞式 I/O 操作会整体增加系统的延迟并降低吞吐量。如果能够在复杂的流程中集成非阻塞、异步通信机制，我们就可以高效处理跨服务之间的网络请求。针对这种场景，WebFlux 是一种非常有效的解决方案。

## 从 WebMVC 到 WebFlux

接下来，我们将讨论 WebMVC 与 WebFlux 之间的差别，而这些差别实际上正是体现在从 WebMVC 到 WebFlux 的演进过程中。让我们先从传统的 Spring WebMVC 技术栈开始说起。

### Spring WebMVC技术栈

一般而言，Web 请求处理机制都会使用“管道-过滤器（Pipe-Filter）”架构模式，而 Spring WebMVC 作为一种处理 Web 请求的典型实现方案，同样使用了 Servlet 中的过滤器链（FilterChain）来对请求进行拦截，如下图所示。

![Drawing 0.png](https://s0.lgstatic.com/i/image6/M01/2C/90/Cgp9HWBlYNSAQ_6xAABLuhAav9c145.png)

图 1 Spring WebMVC 中的过滤器链

我们知道 WebMVC 运行在 Servlet 容器上，这些容器常用的包括 Tomcat、JBoss 等。当 HTTP 请求通过 Servlet 容器时就会被转换为一个 ServletRequest 对象，而最终返回一个 ServletResponse 对象，FilterChain 的定义如下所示。

```java
public interface FilterChain {
    
    public void doFilter (ServletRequest request, ServletResponse response ) throws IOException, ServletException;
 
}
```

当 ServletRequest 通过过滤器链中所包含的一系列过滤器之后，最终就会到达作为前端控制器的 DispatcherServlet。DispatcherServlet 是 WebMVC 的核心组件，扩展了 Servlet 对象，并持有一组 HandlerMapping 和 HandlerAdapter。

当 ServletRequest 请求到达时，DispatcherServlet 负责搜索 HandlerMapping 实例并使用合适的 HandlerAdapter 对其进行适配。其中，HandlerMapping 的作用是根据当前请求找到对应的处理器 Handler，它只定义了一个方法，如下所示。

```java
public interface HandlerMapping {
 
    //找到与请求对应的 Handler，封装为一个 HandlerExecutionChain 返回
	HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception;
}
```

而 HandlerAdapter 根据给定的 HttpServletRequest 和 HttpServletResponse 对象真正调用给定的 Handler，核心方法如下所示。

```java
public interface HandlerAdapter {
 
    //针对给定的请求/响应对象调用目标 Handler
	ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;
}
```

在执行过程中，DispatcherServlet 会在应用上下文中搜索所有 HandlerMapping。日常开发过程中，最常用的 HandlerMapping 包含 BeanNameUrlHandlerMapping 和 RequestMappingHandlerMapping，前者负责检测所有 Controller 并根据请求 URL 的匹配规则映射到具体的 Controller 实例上，而后者基于 @RequestMapping 注解来找到目标 Controller。

如果我们使用了 RequestMappingHandlerMapping，那么对应的 HandlerAdapter 就是 RequestMappingHandlerAdapter，它负责将传入的 ServletRequest 绑定到添加了 @RequestMapping 注解的控制器方法上，从而实现对请求的正确响应。同时，HandlerAdapter 还提供请求验证和响应转换等辅助性功能，使得 Spring WebMVC 框架在日常 Web 开发中非常实用。

作为总结，我梳理了 Spring WebMVC 的整体架构，如下图所示。

![Drawing 1.png](https://s0.lgstatic.com/i/image6/M00/2C/98/CioPOWBlYOGAF_ssAACxp3BYjUM960.png)

图 2 Spring WebMVC 整体架构图

一直以来，Spring WebMVC 是我们开发 Web 服务的主流框架。但要注意的是，尽管 Servlet 本身在新版本中提供了异步非阻塞的通信机制，但 Spring WebMVC 在实现上并不允许在整个请求生命周期中都采用非阻塞式的操作方式。因此，Spring 在尽量沿用原有的开发模式以及 API 设计上提供了支持异步非阻塞的 Spring WebFlux 框架。

### Spring WebFlux 技术栈

介绍完 Spring WebMVC，我们来说说 Spring WebFlux。事实上，前面介绍的 HandlerMapping、HandlerAdapter 等组件在 WebFlux 里都有同名的`响应式版本`，这是 WebFlux 的一种设计理念，即在既有设计的基础上，提供新的实现版本，只对部分需要增强和弱化的地方做了调整。

我们先来看第一个需要调整的地方，显然，我们应该替换掉原有的 Servlet API 以便融入响应式流。因此，在 WebFlux 中，代表请求和响应的是全新的 ServerHttpRequest 和 ServerHttpResponse 对象。

同样，WebFlux 中同样提供了一个过滤器链 WebFilterChain，定义如下。

```java
public interface WebFilterChain {
    Mono<Void> filter(ServerWebExchange exchange);
}
```

这里的 ServerWebExchange 相当于一个上下文容器，保存了 ServerHttpRequest、ServerHttpResponse 以及一些框架运行时状态信息。

在 WebFlux 中，和 WebMVC 中的 DispatcherServlet 相对应的组件是 DispatcherHandler。与 DispatcherServlet 类似，DispatcherHandler 同样使用了一套响应式版本的 HandlerMapping 和 HandlerAdapter 完成对请求的处理。请注意，这两个接口是定义在 org.springframework.web.reactive 包中，而不是在原有的 org.springframework.web 包中。响应式版本的 HandlerMapping 接口定义如下，可以看到这里返回的是一个 Mono 对象，从而启用了响应式行为模式。

```java
public interface HandlerMapping {
	 
	Mono<Object> getHandler(ServerWebExchange exchange);
}
```

同样，我们找到响应式版本的 HandlerAdapter，如下所示。

------

```java
public interface HandlerAdapter {
 
    Mono<HandlerResult> handle(ServerWebExchange exchange, Object handler);
}
```

对比非响应式版本的 HandlerAdapter，这里的 ServerWebExchange 中同时包含了 ServerHttpRequest 和 ServerHttpResponse 对象，而 HandlerResult 则代表了处理结果。相比 WebMVC 中 ModelAndView 这种比较模糊的返回结果，HandlerResult 更加直接和明确。

在 WebFlux 中，同样实现了响应式版本的 RequestMappingHandlerMapping 和 RequestMappingHandlerAdapter，因此我们仍然可以采用注解的方法来构建 Controller。另一方面，WebFlux 中还提供了 RouterFunctionMapping 和 HandlerFunctionAdapter 组合，专门用来提供基于函数式编程的开发模式。这样 Spring WebFlux 的整体架构图就演变成这样。

![Drawing 2.png](https://s0.lgstatic.com/i/image6/M01/2C/90/Cgp9HWBlYO6AE2c_AABMFtMZQAU060.png)

图 3 Spring WebFlux 整体架构图

请注意，在处理 HTTP 请求上，我们需要使用支持异步非阻塞的响应式服务器引擎，常见的包括 Netty、Undertow 以及支持 Servlet 3.1 及以上版本的 Servlet 容器。

## 对比 WebFlux 和 WebMVC 的处理模型

现在我们已经明确了 WebMVC 到 WebFlux 的演进过程，但你可能会问，新的 WebFlux 要比传统 WebMVC 好在哪里呢？从两者的处理模型上入手可以帮助你很好地理解这个问题，我们一起来看一下。

### WebFlux 和 Web MVC 中的处理模型

通过前面的讨论你已经知道 Servlet 是阻塞式的，所以 WebMVC 建立在阻塞 I/O 之上，我们来分析这种模型下线程处理请求的过程。假设有一个工作线程会处理来自客户端的请求，所有请求构成一个请求队列，并由一个线程按顺序进行处理。针对一个请求，线程需要执行两部分工作，首先是接受请求，然后再对其进行处理，如下图所示。

![Drawing 3.png](https://s0.lgstatic.com/i/image6/M00/2C/90/Cgp9HWBlYPeAePjYAABQR4znOfo927.png)

图 4 同步阻塞式处理过程

在前面的示例中，正如你可能注意到的，工作线程的实际处理时间远小于花费在阻塞操作上的时间。这意味着工作线程会被 I/O 读取或写入数据这一操作所阻塞。从这个简单的图中，**我们可以得出结论，线程效率低下**。同时，因为所有请求是排队的，相当于一个请求队列，所以接受请求和处理请求这两部分操作实际上是可以共享等待时间的。

相比之下，WebFlux 构建在非阻塞 API 之上，这意味着没有操作需要与 I/O 阻塞线程进行交互。接受和处理请求的效率很高，如下图所示。

![Drawing 4.png](https://s0.lgstatic.com/i/image6/M00/2C/98/CioPOWBlYQSAV2szAACULiV9Rbo555.png)

图 5 异步非阻塞式处理过程

将上图中所展示的异步非阻塞请求处理与前面的阻塞过程进行比较，我们会注意到，现在没有在读取请求数据时发生等待，工作线程高效接受新连接。然后，提供了非阻塞 I/O 机制的底层操作系统会告诉我们请求数据是否已经接收完成，并且处理器可以在不阻塞的情况下进行处理。

类似的，写入响应结果时同样不需要阻塞，操作系统会在准备好将一部分数据非阻塞地写入 I/O 时通知我们。这样，我们就拥有了最佳的 CPU 利用率。

前面的示例展示了 WebFlux 比 WebMVC 更有效地利用一个工作线程，因此可以在相同的时间内处理更多的请求。那么，如果是在多线程的场景下会发生什么呢？我们来看下面这张图。

![Drawing 5.png](https://s0.lgstatic.com/i/image6/M00/2C/90/Cgp9HWBlYQuAMuj3AABd75iFsms666.png)

图 6 多线程处理过程示意图

从上图中可以看出，多线程模型允许更快地处理排队请求，能够同时接受、处理和响应几乎相同数量的请求。当然，我们明白多线程技术有利有弊。当处理用户请求涉及太多的线程实例时，相互之间就需要协调资源，这是由于它们之间的不一致性会导致性能下降。

#### 处理模型对性能的影响

讲到这里，你可能会问，不同的处理模型对性能会有多大程度的影响呢？这里我们就引用维护Spring 框架的 Pivotal 公司软件开发主管 Biju Kunjummen 的测试结果来对这一问题进行解答。

在 Biju Kunjummen 的测试用例中，他分别基于 WebMVC 所提供的阻塞式 RestTemplate 以及 WebFlux 所提供的非阻塞式 WebClient 工具类对远程 Web 服务发起请求。对于不同组的并发用户（300、1000、1500、3000、5000），他分别发送了一个 delay 属性设置为 300 ms 的请求，每个用户重复该场景 30 次，请求之间的延迟为 1 到 2 秒。测试用例中使用了 Gatling 这款工具来执行压测。

这里我们截取 300 和 3000 并发用户场景下的结果进行对比，如下面两张图所示。

![Drawing 6.png](https://s0.lgstatic.com/i/image6/M00/2C/90/Cgp9HWBlYRSAUYUoAAK7ajk3HpQ553.png)

图 7 300 并发用户下的测试结果

![Drawing 7.png](https://s0.lgstatic.com/i/image6/M00/2C/98/CioPOWBlYRuAQxDNAAK5Dq13-Eg742.png)

图 8 3000 并发用户下的测试结果

可以看到，在 300 并发用户的测试用例下，WebMVC 和 WebFlux 的表现比较接近，意味着在并发量不高的情况下，非阻塞式的请求处理过程并没有太多优势；而在 3000 并发用户下，情况就完全不一样了。无论是吞吐量还是响应时间，WebFlux 都具有压倒性的性能优势。





# WebFlux（上）：如何使用注解编程模式构建异步非阻塞服务？

通过上一讲的介绍，我们已经明确了 Spring 家族中 WebFlux 组件诞生的背景和意义。作为一款新型的 Web 服务开发组件，WebFlux 一方面充分考虑了与原有 Spring MVC 在开发模式上的兼容性，开发人员仍然可以使用基于注解的编程方式来创建响应式 Web 服务；另一方面，WebFlux 也引入了基于函数式编程的全新开发模式。本讲和下一讲将分别对这两种开发模式展开讨论，今天的内容将先关注基于注解的编程模型。

## 引入 Spring WebFlux

Maven pom 文件

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-webflux</artifactId>
</dependency>

<dependency>
    <groupId>io.projectreactor</groupId>
    <artifactId>reactor-test</artifactId>
    <scope>test</scope>
</dependency>
```

`spring-boot-starter-webflux` 是构建响应式 Web 应用程序开发的基础。`reactor-test` 是用来测试 Reactor 框架的测试组件库。

## 使用注解编程模型创建响应式 RESTful 服务

想要使用 WebFlux 构建响应式服务的编程模型，开发人员有两种选择。第一种是使用基于 Java 注解的方式，这种编程模型与传统的 Spring MVC 一致；而第二种则是使用函数式编程模型。这一讲，我们先来介绍第一种实现方式，关于函数式编程模型我们将在下一讲讨论。

### RESTful 服务与传统创建方法

创建一个 Controller

```java
@RestController
public class HelloController {
 
    @GetMapping("/")
    public String hello() {
        return "Hello World!";
    }
}
```

以下 Controller 实现了一个根据订单编号 OrderNumber 获取订单信息的 HTTP 端点

```java
@RestController
@RequestMapping(value="orders")
public class OrderController {
  
    @Autowired
    private OrderService orderService;       
    
    @GetMapping(value = "/{orderNumber}")
    public Order getOrderByOrderNumber(@PathVariable String orderNumber) {   
        Order order = orderService.getOrderByOrderNumber(orderNumber);
        
        return order；
    }
}
```

### 通过注解构建响应式 RESTful 服务

针对前面介绍的两个 RESTful 服务示例，我们将展示如何就响应式编程模型给出它们的响应式版本。

第一个响应式 RESTful 服务来自对原有 HelloController 示例进行响应式改造，改造之后的代码如下所示。

```java
@RestController
public class HelloController {
 
    @GetMapping("/")
    public Mono<String> hello() {
        return Mono.just("Hello World!");
    }
}
```

以上代码只有一个地方值得注意，即 hello() 方法的返回值从普通的 String 对象转化为了一个 Mono 对象。这点是完全可以预见的，使用 Spring WebFlux 与 Spring MVC 的不同之处在于，前者使用的类型都是 Reactor 中提供的 Flux 和 Mono 对象，而不是普通的 POJO。

第一个响应式 RESTful 服务非常简单，在接下来的内容中，我们将更进一步，构建带有一个 Service 层实现的响应式 RESTful 服务。而 Service 层中一般都会使用具体的数据访问层来实现数据操作，但因为响应式数据访问是一个独立的话题，所以我会在后续的“14 | 响应式全栈：响应式编程能为数据访问过程带来什么样的变化？”中进行展开。

这一讲我们还是尽量屏蔽响应式数据访问所带来的复杂性，数据层采用打桩（Stub）的方式来实现这个 Service 层组件。我们将针对常见的订单服务构建一个桩服务 StubOrderService，如下所示。

```java
@Service
public class StubOrderService {
 
    private final Map<String, Order> orders = new ConcurrentHashMap<>();
 
    public Flux<Order> getOrders() {
        return Flux.fromIterable(this.orders.values());
    }
 
    public Flux<Order> getOrdersByIds(final Flux<String> ids) {
        return ids.flatMap(id -> Mono.justOrEmpty(this.orders.get(id)));
    }
 
    public Mono<Order> getOrderById(final String id) {
        return Mono.justOrEmpty(this.orders.get(id));
    }
 
    public Mono<Void> createOrUpdateOrder(final Mono<Order> productMono) {
        return productMono.doOnNext(product -> {
            orders.put(product.getId(), product);
        }).thenEmpty(Mono.empty());
    }
 
    public Mono<Order> deleteOrder(final String id) {
        return Mono.justOrEmpty(this.orders.remove(id));
    }
}
```

StubOrderService 用来对 Order 数据进行基本的 CRUD 操作。我们使用一个位于内存中的 ConcurrentHashMap 对象来保存所有的 Order 对象信息，从而提供一种桩代码实现方案。

这里的 getOrdersByIds() 方法具有代表性，它接收 Flux 类型的参数 ids。Flux 类型的参数代表有多个对象需要处理，这里使用“07 | Reactor 操作符（上）：如何快速转换响应式流？”中所介绍的 flatMap 操作符来对传入的每个 id 进行处理，这也是 flatMap 操作符的一种非常典型的用法。

另外 createOrUpdateOrder() 方法使用 Mono.doOnNext() 方法，将 Mono 对象转换为普通 POJO 对象并进行保存。doOnNext() 方法相当于在响应式流每次发送 onNext 通知时，为消息添加了定制化的处理。

有了桩服务 StubOrderService，我们就可以创建 StubOrderController 来构建具体的响应式 RESTful 服务，它使用 StubOrderService 来完成具体的端点。StubOrderController 中暴露的端点都很简单，我们只是把具体功能代理给了 StubOrderService 中的对应方法，代码如下。

```java
@RestController
@RequestMapping("/orders")
public class StubOrderController {
 
    @Autowired
    private StubOrderService orderService;
 
    @GetMapping("")
    public Flux<Order> getOrders() {
        return this.orderService.getOrders();
    }
 
    @GetMapping("/{id}")
    public Mono<Order> getOrderById(@PathVariable("id") final String id) {
        return this.orderService.getOrderById(id);
    }
 
    @PostMapping("")
    public Mono<Void> createOrder(@RequestBody final Mono<Order> order) {
        return this.orderService.createOrUpdateOrder(order);
    }
 
    @DeleteMapping("/{id}")
    public Mono<Order> delete(@PathVariable("id") final String id) {
        return this.orderService.deleteOrder(id);
    }
}
```

至此，使用注解编程模型创建响应式 RESTful 服务的过程介绍完毕。我们看到 WebFlux 中支持使用与 Spring MVC 相同的注解，两者的主要区别在于底层通信方式是否阻塞。对于简单的场景来说，这两者之间并没有什么太大的差别。但对于复杂的应用而言，响应式编程和背压的优势就会体现出来，可以带来整体性能的提升。

## 案例集成：ReactiveSpringCSS 中的 Web 服务

在介绍完如何使用编程模型创建响应式 RESTful 服务之后，让我们来到 ReactiveSpringCSS 案例中，梳理系统中服务交互之间的应用场景。作为客服系统，其核心业务流程是生成客服工单，而工单的生成通常需要使用到用户账户信息和所关联的订单信息。

在案例中，我们包含三个独立的 Web 服务，分别是用来管理订单的 order-service、管理用户账户的 account-service 以及核心的客服服务 customer-service，这三个服务之间的交互方式如下图所示。

![Drawing 1.png](https://s0.lgstatic.com/i/image6/M00/31/1A/CioPOWBsGyaACJz3AACV3vlgteU433.png)

ReactiveSpringCSS 案例系统中三个服务的交互方式图

通过这个交互图，实际上我们已经可以梳理工单生成的核心流程的伪代码，如下所示。

```java
generateCustomerTicket {
 
    创建 CustomerTicket 对象
 
	从远程 account-service 中获取 Account 对象
 
	从远程 order-service 中获取 Order 对象
 
	设置 CustomerTicket 对象属性
 
	保存 CustomerTicket 对象并返回
}
```

其中从远程 account-service 中获取 Account 对象和从远程 order-service 中获取 Order 对象这两个步骤，都会涉及远程 Web 服务的访问。为此，我们首先需要分别在 account-service 和 order-service 服务中创建对应的 HTTP 端点。今天我们将先基于注解编程模型给出 account-service 中 AccountController 的实现过程，完整的 AccountController 类如下所示。

```java
@RestController
@RequestMapping(value = "accounts")
public class AccountController {
 
    @Autowired
    private AccountService accountService;
 
    @GetMapping(value = "/{accountId}")
    public Mono<Account> getAccountById(@PathVariable("accountId") String accountId) {
 
        Mono<Account> account = accountService.getAccountById(accountId);
        return account;
    }
 
    @GetMapping(value = "accountname/{accountName}")
    public Mono<Account> getAccountByAccountName(@PathVariable("accountName") String accountName) {
 
        Mono<Account> account = accountService.getAccountByAccountName(accountName);
        return account;
    }
 
    @PostMapping(value = "/")
    public Mono<Void> addAccount(@RequestBody Mono<Account> account) {
        
        return accountService.addAccount(account);
    }
 
    @PutMapping(value = "/")
    public Mono<Void> updateAccount(@RequestBody Mono<Account> account) {
        
        return accountService.updateAccount(account);
    }
}
```

可以看到，这里的几个 HTTP 端点都比较简单，基本都是基于 AccountService 完成的 CRUD 操作。需要注意的是，在 addAccount 和 updateAccount 这两个方法中，输入的参数都是一个 Mono 对象，而不是 Account 对象，这意味着 AccountController 将以响应式流的方式处理来自客户端的请求。

### 小结与预告

从今天开始，我们将引入 Spring WebFlux 来构建响应式的 RESTful Web 服务。作为一款全新的开发框架，WebFlux 具有广泛的应用场景，同时也支持两种不同的开发模型。本讲针对注解编程模型给出了 RESTful 服务的开发方法。

这里给你留一道思考题：使用 Spring WebFlux 和 Spring MVC 开发 RESTful 服务有什么联系和区别？

下一讲会继续讨论 Spring WebFlux 的应用，我们将分析全新的函数式编程模型中的编程组件，并完成与 ReactiveSpringCSS 的集成。



--- ### 精选评论 ##### *李： > 如果是基于内存的操作就没有必要响应式了 ######   讲师回复： >   对的，响应式关注于IO的交互 ##### **祥： > 入参为@Requestbody Mono 时以响应式流处理，那么入参为@Pathvarible String id还是以响应式流处理吗 ######   讲师回复： >   对于Web请求而言，因为已经在最终的Subscriber，所以这点上是类似的。在请求处理内容需要以Mono/Flux的方式进行数据传递 ##### *瑞： > 请问一下，对于session和header的处理在响应式中如何处理呢？ ######   讲师回复： >   应该没有本质性的区别，只是获取和存储采用了响应式方式

# 11、WebFlux（下）：如何使用函数式编程模型构建异步非阻塞服务？

上一讲，我们引入了 Spring 框架中专门用于构建响应式 Web 服务的 WebFlux 框架，同时我也给出了两种创建 RESTful 风格 HTTP 端点实现方法中的一种，即注解编程模型。今天，我将介绍另一种实现方法——如何使用函数式编程模型创建响应式 RESTful 服务，这种编程模型与传统的基于 Spring MVC 构建 RESTful 服务的方法有较大差别。

## WebFlux 函数式编程模型

在引入函数式编程模型之前，让我先带你回顾一下 Spring WebFlux 的系统架构图，如下所示。

![图片2.png](https://s0.lgstatic.com/i/image6/M01/32/E0/Cgp9HWBuf--Aek0BAAT9zBvy7qI451.png)

Spring WebFlux 架构图（来自 Spring 官网）

在上图的后半部分，你可以看到在 Spring WebFlux 中，函数式编程模型的核心概念是 Router Functions，对标 Spring MVC 中的 @Controller、@RequestMapping 等标准注解。而 Router Functions 则提供一套函数式风格的 API，其中最重要的就是 Router 和 Handler 接口。我们可以简单把 Router 对应成 RequestMapping，把 Controller 对应为 Handler。

当我发起一个远程调用，传入的 HTTP 请求由 HandlerFunction 处理， HandlerFunction 本质上是一个接收 ServerRequest 并返回 Mono 的函数。ServerRequest 和 ServerResponse 是一对不可变接口，用来提供对底层 HTTP 消息的友好访问。在介绍具体的实现案例之前，让我先从这两个接口开始讲起。

#### ServerRequest

ServerRequest 代表请求对象，可以访问各种 HTTP 请求元素，包括请求方法、URI 和参数，以及通过单独的 ServerRequest.Headers 获取 HTTP 请求头信息。ServerRequest 通过一系列 bodyToMono() 和 bodyToFlux() 方法提供对请求消息体进行访问的途径。例如，如果我们希望将请求消息体提取为 Mono 类型的对象，可以使用如下方法。

```java
Mono<String> string = request.bodyToMono(String.class);
```

而如果我们希望将请求消息体提取为 Flux 类型的对象，可以使用如下方法，其中 Order 是可以从请求消息体反序列化的实体类。



```java
Flux<Order> order = request.bodyToFlux(Order.class);
```

上述的 bodyToMono() 和 bodyToFlux() 两个方法实际上是通用的 ServerRequest.body(BodyExtractor) 工具方法的快捷方式，该方法如下所示。

```java
<T> T body(BodyExtractor<T, ? super ServerHttpRequest> extractor);
```

BodyExtractor 是一种请求消息体的提取器，允许我们编写自己的提取逻辑。请注意 BodyExtractor 提取的对象是一个 ServerHttpRequest 类型的实例，而这个 ServerHttpRequest 是非阻塞的，与之对应的还有一个 ServerHttpResponse 对象。响应式 Web 操作的正是这组非阻塞的 ServerHttpRequest 和 ServerHttpResponse 对象，而不再是 Spring MVC 里的传统 HttpServletRequest 和 HttpServletResponse 对象。

当然，如果我们不需要实现定制化的提取逻辑，就可以使用框架为我们提供的常用的 BodyExtractors 实例。通过 BodyExtractors，上面的例子可以替换为以下形式。

```java
Mono<String> string = 
	request.body(BodyExtractors.toMono(String.class);
	 
Flux<Person> Order= 
	request.body(BodyExtractors.toFlux(Order.class);
```

#### ServerResponse

与ServerRequest 对应，ServerResponse 提供对 HTTP 响应的访问。由于它是不可变的，因此我们可以使用构建器创建一个新的 ServerResponse。构建器允许设置响应状态、添加响应标题并提供响应的具体内容。例如，下面的示例演示了如何通过 ok() 方法创建代表 200 状态码的响应，其中我将响应体的类型设置为 JSON 格式，而响应的具体内容是一个 Mono 对象。



```java
Mono<Order> order = …;
ServerResponse.ok().contentType(MediaType.APPLICATION_JSON)
     .body(order);
```

通过 body() 方法来加载响应内容是构建 ServerResponse 最常见的方法，这里我们将 Order 对象作为返回值。如果想要返回各种类型的对象，我们也可以使用 BodyInserters 工具类所提供的构建方法，如常见的 fromObject() 和 fromPublisher() 方法等。以下示例代码中，我们通过 fromObject() 方法直接返回一个 "Hello World"。

```java
ServerResponse.ok().body(BodyInserters.fromObject("Hello World"));
```

上述方法的背后实际上是利用 BodyBuilder 接口中的一组 body() 方法，来构建一个 ServerResponse 对象，典型的 body() 方法如下所示。

```java
Mono<ServerResponse> body(BodyInserter<?, ? super ServerHttpResponse> inserter);
```

这里我们同样看到了非阻塞式的 ServerHttpResponse 对象。这种 body() 方法比较常见的用法是返回新增和更新操作的结果，你在本讲后续的内容中将会看到这种使用方法。

#### HandlerFunction

将 ServerRequest 和 ServerResponse 组合在一起就可以创建 HandlerFunction。HandlerFunction 也是一个接口，定义如下。

```java
public interface HandlerFunction<T extends ServerResponse> {
 
    Mono<T> handle(ServerRequest request);
}
```

我们可以通过实现 HandlerFunction 接口中的 handle() 方法来创建定制化的请求响应处理机制。例如，以下所示的是一个简单的“Hello World”处理函数代码示例。

```java
public class HelloWorldHandlerFunction implements 
	HandlerFunction<ServerResponse> {
 
        @Override
        public Mono<ServerResponse> handle(ServerRequest request) {
            return ServerResponse.ok().body(
	BodyInserters.fromObject("Hello World"));
        }
};
```

可以看到，这里使用了前面介绍的 ServerResponse 所提供的 body() 方法返回一个 String 类型的消息体。

通常，针对某个领域实体都存在 CRUD 等常见的操作，所以需要编写多个类似的处理函数，比较烦琐。这时候就推荐将多个处理函数分组到一个专门的 Handler 类中。在本讲的后面我同样会演示这种实现方法。

#### RouterFunction

现在，我们已经可以通过 HandlerFunction 创建请求的处理逻辑，接下来需要把具体请求与这种处理逻辑关联起来，RouterFunction 可以帮助我们实现这一目标。RouterFunction 与传统 SpringMVC 中的 @RequestMapping 注解功能类似。

创建 RouterFunction 的最常见做法是使用如下所示的 route 方法，该方法通过使用请求谓词和处理函数创建一个 ServerResponse 对象。

```java
public static <T extends ServerResponse> RouterFunction<T> route(
            RequestPredicate predicate, HandlerFunction<T> handlerFunction) {
 
        return new DefaultRouterFunction<>(predicate, handlerFunction);
}
```

RouterFunction 的核心逻辑位于这里的 DefaultRouterFunction 类中，该类的 route() 方法如下所示。

```java
public Mono<HandlerFunction<T>> route(ServerRequest request) {
            if (this.predicate.test(request)) {
                if (logger.isTraceEnabled()) {
                    String logPrefix = request.exchange().getLogPrefix();
                    logger.trace(logPrefix + String.format("Matched %s", this.predicate));
                }
                return Mono.just(this.handlerFunction);
            }
            else {
                return Mono.empty();
            }
}
```

可以看到，该方法将传入的 ServerRequest 路由到具体的处理函数 HandlerFunction。如果请求与特定路由匹配，则返回处理函数的结果，否则就返回一个空的 Mono。

RequestPredicates 工具类提供了常用的谓词，能够实现包括基于路径、HTTP 方法、内容类型等条件的自动匹配。一个简单的 RouterFunction 示例如下，我们用它来实现对 "/hello-world"请求路径的自动路由，这里用到了前面创建的 HelloWorldHandlerFunction。

```java
RouterFunction<ServerResponse> helloWorldRoute =                RouterFunctions.route(RequestPredicates.path("/hello-world"),
            new HelloWorldHandlerFunction());
```

类似的，我们应该把 RouterFunction 和各种 HandlerFunction 按照需求结合起来一起使用，常见的做法也是根据领域对象来设计对应的 RouterFunction。

路由机制的优势在于它的组合型。两个路由功能可以组合成一个新的路由功能，并通过一定的评估方法路由到其中任何一个处理函数。如果第一个路由的谓词不匹配，则第二个谓词会被评估。请注意组合的路由器功能会按照顺序进行评估，因此在通用功能之前放置一些特定功能是一项最佳实践。在 RouterFunction 中，同样提供了对应的组合方法来实现这一目标，请看下面的代码。

```java
default RouterFunction<T> and(RouterFunction<T> other) {
        return new RouterFunctions.SameComposedRouterFunction<>(this, other);
}
 
default RouterFunction<T> andRoute(RequestPredicate predicate, HandlerFunction<T> handlerFunction) {
        return and(RouterFunctions.route(predicate, handlerFunction));
}
```

我们可以通过调用上述两个方法中的任意一个来组合两个路由功能，其中后者相当于 RouterFunction.and() 方法与 RouterFunctions.route() 方法的集成。以下代码演示了 RouterFunctions 的组合特性。

```java
RouterFunction<ServerResponse> personRoute =
        route(GET("/orders/{id}").and(accept(APPLICATION_JSON)), personHandler::getOrderById)
.andRoute(GET("/orders").and(accept(APPLICATION_JSON)), personHandler::getOrders)
.andRoute(POST("/orders").and(contentType(APPLICATION_JSON)), personHandler::createOrder);
```

RequestPredicates 工具类所提供的大多数谓词也具备组合特性。例如， RequestPredicates.GET(String) 方法的实现如下所示。

```java
public static RequestPredicate GET(String pattern) {
        return method(HttpMethod.GET).and(path(pattern));
}
```

可以看到，该方法是 RequestPredicates.method(HttpMethod.GET) 和 RequestPredicates.path(String) 的组合。我们可以通过调用 RequestPredicate.and(RequestPredicate) 方法或 RequestPredicate.or(RequestPredicate) 方法来构建复杂的请求谓词。

### 案例集成：ReactiveSpringCSS 中的 Web 服务

现在回到 ReactiveSpringCSS 案例，我们已经明确了在案例系统中，customer-service 分别需要访问 account-service 和 order-service 服务中的 Web 服务。在上一讲的内容中，我们已经基于注解编程模型实现了 account-service 中的 AccountController。今天我将继续给你演示 order-service 中 Web 服务的实现过程。

基于函数式编程模型，在 order-service 中，我们编写一个 OrderHandler 专门实现根据 OrderNumber 获取 Order 领域实体的处理函数，如下所示。

```java
@Configuration
public class OrderHandler {
 
    @Autowired
    private OrderService orderService;
 
    public Mono<ServerResponse> getOrderByOrderNumber(ServerRequest request) {
        String orderNumber = request.pathVariable("orderNumber");

        return ServerResponse.ok().body(this.orderService.getOrderByOrderNumber(orderNumber), Order.class);
    }
}
```

在上述代码示例中，我们创建了一个 OrderHandler 类，然后注入 OrderService 并实现了一个 getOrderByOrderNumber() 处理函数。

现在我们已经具备了 OrderHandler，就可以创建对应的 OrderRouter 了，示例代码如下。

```java
@Configuration
public class OrderRouter {
 
    @Bean
    public RouterFunction<ServerResponse> routeOrder(OrderHandler orderHandler) {

        return RouterFunctions.route(
                RequestPredicates.GET("/orders/{orderNumber}")
                    .and(RequestPredicates.accept(MediaType.APPLICATION_JSON)),
                    orderHandler::getOrderByOrderNumber);
    }
}
```

在这个示例中，我们通过访问“/orders/{orderNumber}”端点就会自动触发 orderHandler 中的 getOrderByOrderNumber() 方法并返回相应的 ServerResponse。

接下来，假设我们已经分别通过远程调用获取了目标 Account 对象和 Order 对象，那么 generateCustomerTicket 方法的执行流程就可以明确了。基于响应式编程的实现方法，我们可以得到如下所示的示例代码。

```java
public Mono<CustomerTicket> generateCustomerTicket(String accountId, String orderNumber) {
 
        // 创建 CustomerTicket 对象
        CustomerTicket customerTicket = new CustomerTicket();
        customerTicket.setId("C_" + UUID.randomUUID().toString());
 
        // 从远程 account-service 获取 Account 对象
        Mono<AccountMapper> accountMapper = getRemoteAccountByAccountId(accountId);

        // 从远程 order-service 中获取 Order 对象
        Mono<OrderMapper> orderMapper = getRemoteOrderByOrderNumber(orderNumber);

        Mono<CustomerTicket> monoCustomerTicket = 
                Mono.zip(accountMapper, orderMapper).flatMap(tuple -> {
            AccountMapper account = tuple.getT1();
            OrderMapper order = tuple.getT2();

            if(account == null || order == null) {
                return Mono.just(customerTicket);
            }

            // 设置 CustomerTicket 对象属性
            customerTicket.setAccountId(account.getId());
            customerTicket.setOrderNumber(order.getOrderNumber());
            customerTicket.setCreateTime(new Date());
            customerTicket.setDescription("TestCustomerTicket");

            return Mono.just(customerTicket);
        });

        // 保存 CustomerTicket 对象并返回
        return monoCustomerTicket.flatMap(customerTicketRepository::save);
}
```

显然，这里的 getRemoteAccountById 和 getRemoteOrderByOrderNumber 方法都涉及了非阻塞式的远程 Web 服务的调用，这一过程我们将放在下一讲中详细介绍。

请注意，到这里时使用了 Reactor 框架中的 zip 操作符，将 accountMapper 流中的元素与 orderMapper 流中的元素按照一对一的方式进行合并，合并之后得到一个 Tuple2 对象。然后，我们再分别从这个 Tuple2 对象中获取 AccountMapper 和 OrderMapper 对象，并将它们的属性填充到所生成的 CustomerTicket 对象中。最后，我们通过 flatMap 操作符调用了 customerTicketRepository 的 save 方法完成了数据的持久化。这是 zip 和 flatMap 这两个操作符非常经典的一种应用场景，你需要熟练掌握。

### 小结与预告

好了，那么本讲内容就说到这。延续上一讲，我们接着讨论了 Spring WebFlux 的使用方法，并给出了基于函数式编程模型的 RESTful 端点创建方法。在这种开发模型中，开发人员需要重点把握 ServerRequest、ServerResponse、HandlerFunction 以及 RouterFunction 这四个核心对象的使用方法。

这里给你留一道思考题：你知道在 WebFlux 函数式编程模型中包含哪些核心编程对象吗？

现在，我们已经通过 WebFlux 构建了响应式 Web 服务，下一步就是如何来消费它们了。Spring 也专门提供了一个非阻塞式的 WebClient 工具类来完成这一目标，下一讲我就来和你系统地讨论这个工具类的使用方法，到时见。



--- ### 精选评论 ##### *晨： > 老师你好，在项目中，背压怎么设置，设置到哪块 ######   讲师回复： >   就是使用一组onBackpressureXXX操作符，后面案例中会有示例