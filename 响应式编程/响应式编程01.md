响应式编程是一种新的编程技术，其目的是构建响应式系统。对于响应式系统而言，任何时候都需要确保具备即时响应性，这是大多数日常业务场景所需要的，但却是一项非常复杂而有挑战性的任务，需要对相关技术体系有深入的了解。
那么在今天的课程中，我会先从传统的开发模式讲起，并引入异步执行的相关技术，因为异步执行是响应式技术体系的基础。在此基础上，我将为你详细阐述响应式编程的各项技术特点。

# 从传统开发模式到异步执行技术

现实的开发过程普遍采用的是同步阻塞式的开发模式，以实现业务系统。在这种模式下，开发、调试和维护都很简单。我们先以 Web 系统中最常见的 HTTP 请求为例，来分析其背后的 I/O 模型，从而让你对传统开发模式有进一步的了解。

## Web 请求与 I/O 模型

如果你使用 Spring 框架开发过 Web 应用程序，那么你一定对下面这段代码非常熟悉。

```java
RestTemplate restTemplate = new RestTemplate();
ResponseEntity<User> restExchange = restTemplate.exchange(
    "http://localhost:8080/users/{userName}", HttpMethod.GET, null, User.class, userName);
User result = restExchange.getBody();
process(result);  
```

这里，我们传入用户名 UserName 调用远程服务获取一个 User 对象，技术上使用了 Spring MVC 中的 RestTemplate 模板工具类，通过该类所提供的 exchange 方法对远程 Web 服务所暴露的 HTTP 端点发起了请求，并对所获取的响应结果进行进一步处理。

这是日常开发过程中非常具有代表性的一种场景，整个过程很熟悉也很自然。

那么，这个实现过程背后有没有一些可以改进的地方呢？为了更好地分析整个调用过程，我们假设服务的提供者为服务 A，而服务的消费者为服务 B，那么这两个服务的交互过程应该是下图所示这样的。

![](https://s0.lgstatic.com/i/image6/M00/21/36/Cgp9HWBUHYyAWK7RAACbGUwiNJI141.png)

​																图 1 服务 A 和服务 B 的交互过程图

可以看到，当服务 B 向服务 A 发送 HTTP 请求时，线程 B 只有在发起请求和响应结果的一小部分时间内在有效使用 CPU，而更多的时间则只是在阻塞式地等待来自服务 A 中线程的处理结果。显然，整个过程的 CPU 利用效率是很低的，很多时间线程被浪费在了 I/O 阻塞上，无法执行其他的处理过程。

更进一步，我们继续分析服务 A 中的处理过程。如果我们采用典型的 Web 服务分层架构，那么就可以得到如图 2 所示的用户信息查询实现时序图，这是日常开发过程中普遍采用的一种实现方式。

一般我们使用 Web 层所提供的 HTTP 端点作为查询的操作入口，然后该操作入口会进一步调用包含业务逻辑处理的服务层，而服务层再调用数据访问层，数据访问层就会连接到数据库获取数据。数据从数据库中获取之后逐层向上传递，最后返回给服务的调用者。

![](https://s0.lgstatic.com/i/image6/M01/21/34/CioPOWBUIG2APMzTAAG4Hgs9bQk059.png)

​												图 2 基于传统实现方法的用户信息查询场景时序图

显然图 2 所展示的整个过程中，每一步的操作过程都存在着前面描述的线程等待问题。也就是说，整个技术栈中的每一个环节都可能是同步阻塞的。

针对同步阻塞问题，在技术上也可以引入一些实现技术来将同步调用转化为异步调用。我们一起来看一下。

## 异步调用的实现技术

在 Java 世界中，为了实现异步非阻塞，一般会采用回调和 Future 这两种机制，但这两种机制都存在一定局限性。

回调的含义如图 3 所示，即服务 B 的 methodB() 方法调用服务 A 的 methodA() 方法，然后服务 A 的 methodA() 方法执行完毕后，再主动调用服务 B 的 callback() 方法。

![](https://s0.lgstatic.com/i/image6/M01/21/34/CioPOWBUIHmAV0OeAACBv4hHbo0240.png)

回调体现的是一种双向的调用方式，实现了服务 A 和服务 B 之间的解耦。在这个 callback 回调方法中，回调的执行是由任务的结果来触发的，所以我们就可以异步来执行某项任务，从而使得调用链路不发生任何的阻塞。

回调的最大问题是复杂性，一旦在执行流程中包含了多层的异步执行和回调，那么就会形成一种嵌套结构，给代码的开发和调试带来很大的挑战。所以回调很难大规模地组合起来使用，因为很快就会导致代码难以理解和维护，从而造成所谓的“回调地狱”问题。

讲完回调，我们来看 Future。可以把 Future 模式简单理解为这样一种场景：我们有一个需要处理的任务，然后把这个任务提交到 Future，Future 就会在一定时间内完成这个任务，而在这段时间内我们可以去做其他事情。作为 Future 模式的实现，Java 中的 Future 接口只包含如下 5 个方法。

```java
public interface Future<V> {

    //取消任务的执行
    boolean cancel(boolean mayInterruptIfRunning);

    //判断任务是否已经取消
    boolean isCancelled();

    //判断任务是否已经完成
    boolean isDone();

    //等待任务执行结束并获取结果
    V get() throws InterruptedException, ExecutionException;

    //在一定时间内等待任务执行结束并获取结果
    V get(long timeout, TimeUnit unit)?
        throws InterruptedException, ExecutionException, TimeoutException;
}
```

从这些基础方法中可以看到，我们可以通过对任务进行灵活的控制和判断，来达到一定的异步执行效果。

但从本质上讲，Future 以及由 Future 所衍生出来的 CompletableFuture 等各种优化方案就是一种多线程技术。多线程假设一些线程可以共享一个 CPU，而 CPU 时间能在多个线程之间共享，这一点就引入了“上下文切换”的概念。

如果想要恢复线程，就需要涉及加载和保存寄存器等一系列计算密集型的操作。因此，大量线程之间的相互协作同样会导致资源利用效率低下。

那么以上我们对传统开发模式以及异步调用实现方式做了一些回顾，下面引出本讲的重点内容——响应式编程实现方法。



## 响应式编程实现方法

### 观察者模式和发布-订阅模式

在引入响应式编程技术之前，我们同样先来回顾一个大家可能都知道的设计模式，即观察者模式。观察者模式拥有一个主题（Subject），其中包含其依赖者列表，这些依赖者被称为观察者（Observer）。主题可以通过一定的机制将任何状态变化通知到观察者。针对前面介绍的用户信息查询操作，我们同样可以应用观察者模式，如下图所示。

![](https://s0.lgstatic.com/i/image6/M01/21/34/CioPOWBUIISALAvPAACra6PO8ac132.png)

​																	图 4 观察者模式下的用户信息获取过程

如果系统中存在一批类似上图中的用户信息获取场景，针对每个场景都实现一套观察者模式显然是不合适的。更好的方法是使用发布-订阅模式，该模式可以认为是对观察者模式的一种改进。

在这一模式中，发布者和订阅者之间可以没有直接的交互，而是通过发送事件到事件处理平台的方式来完成整合，如下图所示。

![](https://s0.lgstatic.com/i/image6/M01/21/34/CioPOWBUIIuAWD5cAAC5GORZj7Y689.png)

​																	图 5 发布-订阅模式下的用户信息获取过程

由此可见，通过发布-订阅模式，我们可以基于同一套事件发布机制和事件处理平台来应对多种业务场景，不同的场景只需要发送不同的事件即可。

同样，如果我们聚焦于服务 A 的内部，那么从 Web 服务层到数据访问层，再到数据库的整个调用链路，同样可以采用发布-订阅模式进行重构。这时候，我们希望当数据库中的数据一有变化就通知上游组件，而不是上游组件通过主动拉取数据的方式来获取数据。下图展示了这一过程。

![](https://s0.lgstatic.com/i/image6/M01/21/38/Cgp9HWBUIJSAXaqcAAH7KKi1LAk978.png)

​															图 6 基于响应式实现方法的用户信息查询场景时序图

显然，现在我们的处理方式发生了本质性的变化。图 6 中，我们没有通过同步执行的方式来获取数据，而是订阅了一个 UserChangedEvent 事件。UserChangedEvent 事件会根据用户信息是否发生变化而进行触发，并在 Web 应用程序的各个层之间进行传播。如果我们在这些层上都对这个事件进行了订阅，那么就可以对其分别进行处理，并最终将处理结果从服务 A 传播到服务 B 中。



#### 数据流与响应式

接下来，我们扩大讨论范围，来想象系统中可能会存在着很多类似 UserChangedEvent 这样的事件。每一种事件会基于用户的操作或者系统自身的行为而被触发，并形成了一个事件的集合。针对事件的集合，我们可以把它们看成是一串串联起来的数据流，而系统的响应能力就体现在对这些数据流的即时响应过程上。

数据流对于技术栈而言是一个全流程的概念。也就是说，无论是从底层数据库，向上到达服务层，最后到 Web 服务层，抑或是在这个流程中所包含的任意中间层组件，整个数据传递链路都应该是采用事件驱动的方式来进行运作的。

这样，我们就可以不采用传统的同步调用方式来处理数据，而是由处于数据库上游的各层组件自动来执行事件。**这就是响应式编程的核心特点**。

相较传统开发所普遍采用的“拉”模式，在响应式编程下，基于事件的触发和订阅机制，这就形成了一种类似“推”的工作方式。这种工作方式的优势就在于，生成事件和消费事件的过程是异步执行的，所以线程的生命周期都很短，也就意味着资源之间的竞争关系较少，服务器的响应能力也就越高。

## 响应式宣言和响应式系统

讲到这里，在理论和实践的结合下，你应该已经意识到，所谓的“响应式”并不是一件颠覆式的事情，而只是一种新型的编程模式。它不局限于某种开发框架，也并非解决分布式环境下所有问题的银弹，而是随着技术的发展自然而然诞生的一种技术体系。

关于响应式，业界也存在一个著名的响应式宣言，下图就是响应式宣言的官方网站给出的，对于这一宣言的图形化描述。

![](https://s0.lgstatic.com/i/image6/M01/21/35/CioPOWBUIJ6AeBjQAADBZrcBck4263.png)

​																								图 7 响应式宣言

可以看到，即时响应性（Responsive）、回弹性（Resilient）、弹性（Elastic）以及消息驱动（Message Driven）构成了响应式宣言的主体内容。响应式宣言认为，具备上图中各个特性的系统，就可以称为响应式系统。

而这些特性又可以分为三个层次，其中即时响应性、可维护性（Maintainable）和扩展性（Extensible）体现的是价值，回弹性和弹性是表现形式，而消息驱动则是实现手段。

从设计理念上讲，即时响应性指的就是无论在任何时候，系统都会及时地做出响应，并对那些出现的问题进行快速的检测和处理，这是可用性的基石。

要注意，这里的回弹性和弹性比较容易混用。**所谓回弹性指的是系统在出现失败时，依然能够保持即时响应性；而弹性则是指的系统在各种请求压力之下，都能保持即时响应性**。

最后的消息驱动指的是响应式系统需要构建异步的消息通信机制。你可以把这里的消息等同于前面提到的事件，通过使用消息通信，可以通过在系统中实现连续的数据流，从而达到对流量进行控制的管理目标。我们知道消息通信是非阻塞的，非阻塞的通信使得只有在有消息到来时才需要资源的投入，而避免了很多同步等待导致的资源浪费。





# 背压机制

## 流的概念

简单来讲，所谓的流就是`由生产者生产并由一个或多个消费者消费的元素序列`。这种生产者/消费者模型也可以被称为发布者/订阅者模型，我在上一讲中已经介绍过这个模型。而关于流的介绍，我将从两方面入手，首先明确流的分类，然后再来讨论如何进行流量控制，流量控制是讨论数据流的核心话题。

## 流的处理模型

关于流的处理，存在两种基本的实现机制。一种就是传统开发模式下的“拉”模式，即消费者主动从生产者拉取元素；而另一种就是上一讲中分析的“推”模式，在这种模式下，生产者将元素推送给消费者。相较于“拉”模式，“推”模式下的数据处理的资源利用率更好，下图所示的就是一种典型的推模式处理流程。

![](https://s0.lgstatic.com/i/image6/M01/21/38/Cgp9HWBUIRCAHSoEAACQmzpsJME739.png)

​																	图 1 推模式下的数据流处理方式示意图

上图中，数据流的生产者会持续地生成数据并推送给消费者。这里就引出了流量控制问题，即如果数据的生产者和消费者处理数据的速度是不一致的，我们应该如何确保系统的稳定性呢？

## 流量控制

先来看第一种场景，即生产者生产数据的速率小于消费者的场景。在这种情况下，因为消费者消费数据没有任何压力，也就不需要进行流量的控制。

现实中，更多的是生产者生产数据的速率大于消费者消费数据的场景。这种情况比较复杂，因为消费者可能因为无法处理过多的数据而发生崩溃。针对这种情况的一种常见解决方案是在生产者和消费者之间添加一种类似于消息队列的机制。我们知道队列具有存储并转发的功能，所以可以由它来进行一定的流量控制，效果如下图所示。

![](https://s0.lgstatic.com/i/image6/M00/21/35/CioPOWBUIRiAedZZAACVgTxgC80957.png)

图 2 添加队列机制之后的生产者/消费者场景示意图

现在，问题的关键就转变为**如何设计一种合适的队列**。通常，我们可以选择三种不同类型的队列来分别支持不同的功能特性。

**无界队列**

第一种最容易想到的队列就是无界队列（Unbounded Queue），这种队列原则上拥有无限大小的容量，可以存放所有生产者所生产的消息，如下图所示。

![](https://s0.lgstatic.com/i/image6/M01/21/38/Cgp9HWBUISGAJrh5AACOo3oalK8601.png)

显然，无界队列的优势就是确保了所有消息都能得到消费，但显然会降低系统的回弹性，因为没有一个系统拥有无限的资源。一旦内存等资源被耗尽，系统可能就崩溃了。

**有界丢弃队列**

与无界队列相对的，更合适的方案是选择一种有界队列。为了避免内存溢出，我们可以使用这样一个队列，一般队列的容量满了，就忽略后续传入的消息，如下图所示。

![](https://s0.lgstatic.com/i/image6/M00/21/35/CioPOWBUISqAal3JAACp2GTWvZM658.png)

图 4 有界丢弃队列结构示意图

上图中，可以看出这个有界队列的容量为 6，所以第 7 和第 8 个元素被丢弃了。然后当消费者消费了一部分消息之后，队列出现了新的空闲位置，后续的消息就又被填充到队列中。当然，这里可以设置一些丢弃元素的策略，比方说按照优先级或先进先出等。

有界丢弃队列考虑了资源的限制，比较适合用于允许丢消息的业务场景，但在消息重要性很高的场景显然不可能采取这种队列。

**有界阻塞队列**

如果需要确保消息不丢失，则需要引入有界阻塞队列。在这种队列中，我们会在队列消息数量达到上限后阻塞生产者，而不是直接丢弃消息，如下图所示。

![](https://s0.lgstatic.com/i/image6/M01/21/38/Cgp9HWBUIUOAChJ1AACq6l5LR5Y136.png)

​										图 5 有界阻塞队列结构示意图

上图中，队列的容量同样是 6，所以当第 7 个元素到来时，发现队列已经满了，那么生产者就会一直等到队列空间的释放而产生阻塞行为。显然，这种阻塞行为是不可能实现异步操作的，所以结合上一讲中的讨论结果，无论从回弹性、弹性还是即时响应性出发，有界阻塞队列都不是我们想要的解决方案。



## 背压机制

讲到这里，我们已经明确，纯“推”模式下的数据流量会有很多不可控制的因素，并不能直接应用，而是需要在“推”模式和“拉”模式之间考虑一定的平衡性，从而优雅地实现流量控制。这就需要引出响应式系统中非常重要的一个概念——背压机制（Backpressure）。

什么是背压？简单来说就是下游能够向上游反馈流量请求的机制。通过前面的分析，我们知道如果消费者消费数据的速度赶不上生产者生产数据的速度时，它就会持续消耗系统的资源，直到这些资源被消耗殆尽。

这个时候，就需要有一种机制使得消费者可以根据自身当前的处理能力通知生产者来调整生产数据的速度，这种机制就是背压。采用背压机制，消费者会根据自身的处理能力来请求数据，而生产者也会根据消费者的能力来生产数据，从而在两者之间达成一种动态的平衡，确保系统的即时响应性。



## 响应式流规范

关于流量控制我们已经讨论了很多，而针对流量控制的解决方案以及背压机制都包含在响应式流规范中，其中包含了响应式编程的各个核心组件，让我们一起来看一下。

### 响应式流的核心接口

在 Java 中，响应式流规范只定义了四个核心接口，即 `Publisher<T>`、`Subscriber<T>`、`Subscription` 和 `Processor<T,R>`

#### `Publisher<T>`

Publisher 代表的就是一种可以生产无限数据的发布者，该接口定义如下所示。

```java
public interface Publisher<T> {
    /*
    	注意：这里是一种监听器模式的实现，所以这里的执行逻辑是产生数据的发布者主动向一个订阅者
    	发送数据
    */
    public void subscribe(Subscriber<? super T> s);
}
```

可以看到，Publisher 根据收到的请求向当前订阅者 Subscriber 发送元素。

> 注：Publisher 首先会和 Subscriber 建立连接，并且 Subscriber 会向 Publisher 发送一次异步请求，表明自己希望能够得到多少个响应结果，之后等这个异步得到响应后再由 Publisher 通过 subscribe 方法发送给 Subscriber。



**注意事项：**

- Publisher 向 Subscriber 发送的 onNext 信号次数不得超过订阅者请求的元素个数（调用 onNext 向下游传播数据）

- 如果 Publisher 执行任务失败了，需要调用 onError 告知订阅者。

- Publisher#subscribe 方法内部必须调用 Subscriber#onSubscribe 方法。

	> onSubscribe 方法：onSubscribe() 从命名上看就是一个回调方法，当发布者的 subscribe() 方法被调用时就会触发这个回调，而我们知道 subscribe() 方法被调用的时机就是它所监听的事件执行了。也就是说，当异步调用产生了返回结果时，会执行 subscribe 方法，而 subscribe 方法内部则会先调用 onSubscribe() 方法，它的作用是让订阅者做好初始化，准备开始接收后面的元素。

- 一个发布者允许同时存在多个订阅者。



 



#### `Subscriber <T>`

对应的，Subscriber 代表的是一种可以从发布者那里订阅并接收元素的订阅者。Subscriber `<T>` 接口定义如下所示。

```java
public interface Subscriber<T> {
    // 
    public void onSubscribe(Subscription s);
    public void onNext(T t);
    public void onError(Throwable t);
    public void onComplete();
}
```

我们注意到 Subscriber 接口包含了一组有用的方法，这组方法构成了数据流请求和处理的基本流程，我们一一来看一下。

其中，onSubscribe() 从命名上看就是一个回调方法，当发布者的 subscribe() 方法被调用时就会触发这个回调。而在该方法中有一个参数 Subscription，可以把这个 Subscription 看作是一种用于订阅的上下文对象。Subscription 对象中包含了这次回调中订阅者想要向发布者请求的数据个数。

当订阅关系已经建立，那么发布者就可以调用订阅者的 onNext() 方法向订阅者发送一个数据。这个过程是持续不断的，直到所发送的数据已经达到 Subscription 对象中所请求的数据个数。这时候 onComplete() 方法就会被触发，代表这个数据流已经全部发送结束。而一旦在这个过程中出现了异常，那么就会触发 onError() 方法，我们可以通过这个方法捕获到具体的异常信息进行处理，而数据流也就自动终止了。

**注意事项：**

- 为了接收到 onNext 发生的信号，订阅者必须调用 Subscription#request(long n) 来向发布者请求数据。
- 只能存在一个活跃的订阅。（如果当前Subscriber已经有了一个活跃的订阅的话，它在接收到另一个Publisher传递的onSubscribe方法时，必须调用Subscription#cancel来取消另外一个订阅，这样就能保证订阅者不会同时与多个发布者产生交互）
- 调用 Subscription#cancel 之后仍有可能有 onNext 信号发送。这是因为发布者并不会立即执行 cancel，在执行 cancel 之前仍然可能有一部分响应会发送给下游，此时 Subscription 仍然需要处理这一部分元素。





#### Subscription

Subscription 代表的就是一种订阅上下文对象，它在订阅者和发布者之间进行传输，表明两者之间的一种契约关系。

Subscription 接口定义如下所示。

```java
public interface Subscription {
    public void request(long n);
    public void cancel();
}
```

这里的 request() 方法用于请求 n 个元素，订阅者可以通过不断调用该方法来向发布者请求数据；而 cancel() 方法显然是用来取消这次订阅。请注意，**Subscription 对象是确保生产者和消费者针对数据处理速度达成一种动态平衡的基础，也是流量控制中实现背压机制的关键所在**，



我们可以通过下图来进一步理解整个数据请求和处理过程。

![](https://s0.lgstatic.com/i/image6/M00/21/38/Cgp9HWBUIZqASTpVAADEEHREqvE168.png)

图 6 Subscription 与背压机制示意图

Publisher、Subscriber 和 Subscription 接口是响应式编程的核心组件，响应式流规范也只包含了这些接口，因此是一个非常抽象且精简的接口规范。结合前面的讨论结果，我们可以明确，响应式流规范实际上提供了一种“推-拉”结合的混合数据流模型。

当然，响应式流规范非常灵活，还可以提供独立的“推”模型和“拉”模型。如果为了实现纯“推”模型，我们可以考虑一次请求足够多的元素；而对于纯“拉”模型，相当于就是在每次调用 Subscriber 的 onNext() 方法时只请求一个新元素。



#### Proceor接口

```java

```

Proceor 是一种处理的状态，所以，它既是一个 Publisher，也是一个 Subscriber。





### 响应式流的技术生态圈

响应式流是一种规范，而该规范的核心价值就在于为业界提供了一种非阻塞式背压的异步流处理标准。各个供应商都可以基于该规范实现自己的响应式开发库，而这些开发库之间则可以做到互相兼容、相互交互。

目前，业界主流响应式开发库包括 RxJava、Akka、Vert.x 以及 Project Reactor。在本课程中，我们将重点介绍 Project Reactor，它是 Spring 5 中所默认集成的响应式开发库。





## Q&A

```
>>订阅者通过subscribe方法订阅
>>发布者回调onSubscribe方法
>>通过Subscription沟通协调
>>发布订阅关系建立好后，发布者调用onNext方法，发送数据，直到完成发送的个数。发送完成会触发onComplete方法，异常则触发onError方法，数据流也会停止。
```



# 响应式编程的应用场景

## 响应式编程的应用场景分析

本质上，我们可以认为响应式编程并不仅仅是一种编程技术，而更是一种架构设计的系统方法，因此可以应用于任何地方。它既可以用于简单的 Web 应用系统，也可以用于大型企业解决方案。当然，对于响应式数据流，我们也完全可以基于它来构建流式系统或大数据系统。

数据流处理是响应式编程的一大应用场景。流式系统的主要特点是低延迟和高吞吐量。对于这类系统，大多数数据是从服务器端传出的，因此客户端扮演消费者的角色。这个时候，通过使用非阻塞式通信可以确保资源得到高效的利用，从而实现低延迟和高吞吐量。流式系统的表现形式也可以有很多，日常的日志埋点和分析、服务运行时的状态采集等都属于这种类型。

针对高并发流量，通常涉及大量的 I/O 操作。相较于传统的同步阻塞式 I/O 模型，响应式编程所具备的异步非阻塞式 I/O 模型非常适合应对处理高并发流量的业务场景。这类场景中比较典型的一种表现形式就是微服务架构中的 API 网关，因为网关的作用就是用来响应来自前端系统的流量并将其转发到后端服务。

讲到微服务架构，如何构建一个具有异步非阻塞式的请求处理流程的 Web 服务也是核心诉求，我们需要高效处理跨服务之间的网络请求。针对这种场景，响应式编程及其相关技术体系同样也是一种非常有效的解决方案。

## 响应式编程在主流开源框架中的应用

响应式编程在日常开发过程中日益得到广泛的应用，结合上文所分析的三种典型应用场景，这里我们以对应的 Netflix Hystrix、Spring Cloud Gateway 以及 Spring WebFlux 这三款主流的开源框架为例，解析这些框架背后所应用的响应式编程技术。

### Netflix Hystrix 中的滑动窗口

在 Spring Cloud 微服务开发框架中，存在一个 Spring Cloud Netflix Hystrix 组件，该组件基于 Netflix Hystrix 实现了服务熔断功能。Netflix Hystrix 是 Netflix 开源的一款容错库，使用了 HystrixCircuitBreaker 类来实现熔断器。该类通过一个 circuitOpen 状态位控制着整个熔断判断流程，而这个状态位本身的状态值则取决于系统目前的执行数据和健康指标。

那么，HystrixCircuitBreaker 如何动态获取系统运行时的各项数据呢？这里就使用到了一个 HealthCountsStream 类，从命名上不难看出，这就是一种数据流。HealthCountsStream 在设计上采用了一种特定的机制，即滑动窗口（Rolling Window）机制，而 Hystrix 在实现这一机制时大量采用了数据流处理方面的技术以及 RxJava 这个响应式编程框架。

Hystrix 以秒为单位来统计系统中所有请求的处理情况，然后每次取最近 10 秒的数据来进行计算。如果失败率超过一定阈值，就进行熔断。这里的 10 秒就是一个滑动窗口，参考其官网的一幅图，如下所示。

![](https://s0.lgstatic.com/i/image6/M00/24/07/Cgp9HWBYDkqAfjLrAAImzCk-l7s672.png)

图 1 Hystrix 滑动窗口效果图（来自 Hystrix 官网）

上图演示了 Hystrix 滑动窗口策略，把 10 秒时间拆分成了 10 个格子，我们把这种格子称为桶 Bucket。每个桶中的数据就是这一秒中所处理的请求数量，并针对处理结果的状态做了分类。然后每当收集好一个新的桶后，就会丢弃掉最旧的一个桶，所以窗口是滑动的。

那么如何来实现这个滑动窗口呢？我们转换一下思路，可以把系统运行时所产生的所有数据都视为一个个的事件，这样滑动窗口中每个桶的数据都来自源源不断的事件。同时，对于这些生成的事件，我们通常需要对其进行转换以便进行后续的操作。这两点构成了实现滑动窗口的设计目标和方法。

在技术实现的选型上，Hystrix 采用了基于响应式编程思想的 RxJava。与其他响应式编程框架一样，RxJava 同样实现了上一讲中介绍的响应式流规范。使用 RxJava 的一大好处是可以通过 RxJava 的一系列操作符来实现滑动窗口，包括 window、flatMap 和 reduce 等。其中 window 操作符是把当前流中的元素收集到另外的流序列；flatMap 操作符把流中的每个元素转换成一个流，再把转换之后得到的所有流中的元素进行合并。而后 reduce 操作符对流中包含的所有元素进行累积操作，得到一个包含计算结果的流。这些操作符我会在“07 | Reactor 操作符（上）：如何快速转换响应式流”中详细为你介绍。

在 Hystrix 中，HealthCountsStream 的子类 BucketedCounterStream 将基础数据事件流汇总成 Bucket，如下所示。

```java
this.bucketedStream = Observable.defer(new Func0<Observable<Bucket>>() {
            @Override
            public Observable<Bucket> call() {
                return inputEventStream
                        .observe()
	// 使用window操作符收集一个Bucket时间内的数据
.window(bucketSizeInMs, TimeUnit.MILLISECONDS) 
// 将每个window内聚集起来的事件集合汇总成Bucket
.flatMap(reduceBucketToSummary).startWith(emptyEventCountsToStart);                       }
	        });
```

可以看到，这里分别使用了前面介绍的 window 和 flatMap 操作符来完成 Bucket 的构建。请注意，该方法返回的是一个 Observable`<Bucket>` 对象。在 RxJava 中，Observable 代表的就是一个无限流对象。

我们再来看 BucketedCounterStream 的子类 BucketedRollingCounterStream 类，该类的构造函数中同样存在一个类似的方法，如下所示（为了避免过于复杂，裁剪了部分代码）。

```java
this.sourceStream = bucketedStream
	 //将N个Bucket进行汇总
	.window(numBuckets, 1)
	//汇总成一个窗口
	.flatMap(reduceWindowToSummary) 
     …
     //添加背压控制
	.onBackpressureDrop();
```

上述方法中基于父类 BucketedCounterStream 已经汇总的 bucketedStream 进行开窗处理，从而获取一个 sourceStream，这个 sourceStream 就是滑动窗口的最终形态。最后的 onBackpressureDrop() 语句是 RxJava 中提供的一种背压机制。我们在上一讲中讨论了背压机制的概念和作用，而在这里就看到了这一机制的具体应用。

作为总结，Hystrix 巧妙地运用了 RxJava 中的 window、flatMap 等操作符来将单位窗口时间内的事件，以及将一个窗口大小内的 Bucket 聚集到一起形成滑动窗口，并基于滑动窗口集成指标数据。这个设计思想非常巧妙，值得我们深入研究并对基于流的处理过程加以尝试和应用。

### Spring Cloud Gateway 中的过滤器

Spring Cloud Gateway 是 Spring Cloud 微服务开发框架中的另一个核心组件，是 Spring 官方自己开发的一款 API 网关。在技术体系上，Spring Cloud Gateway 基于最新的 Spring 5 和 Spring Boot 2，以及用于响应式编程的 Project Reactor 框架，提供的是响应式、非阻塞式 I/O 模型。所以性能上比 Netflix 中的 Zuul 网关要更胜一筹。

Spring Cloud Gateway 中的核心概念就是过滤器（Filter），围绕过滤器的请求处理流程如下图所示。

![](https://s0.lgstatic.com/i/image6/M00/24/07/Cgp9HWBYDj6AFo0eAACtCU1brX4578.png)

图 2 Spring Cloud Gateway 中的过滤器架构

过滤器用于在响应 HTTP 请求之前或之后修改请求本身及对应的响应结果。Spring Cloud Gateway 中提供了一个全局过滤器（GlobalFilter）的概念，对所有路由都生效。我们来演示一下如何使用全局过滤器来对所有 HTTP 请求进行拦截，具体做法是实现 GlobalFilter 接口，示例代码如下所示。

```java
@Configuration
public class JWTAuthFilter implements GlobalFilter {
 
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest.Builder builder = exchange.getRequest().mutate();
        builder.header("Authorization","Token");
        return chain.filter(exchange.mutate().request(builder.build()).build());
    }
}
```

以上代码展示了如何利用全局过滤器在所有的请求中添加 Header 的实现方法。在这个示例中，我们对所有经过 API 网关的 HTTP 请求添加了一个消息头，用来设置与访问 Token 相关的安全认证信息。

请注意，这里的 filter 方法返回了一个 Mono 对象，你可能会问这个 Mono 对象究竟是什么呢？事实上，这是在响应式编程框架 Project Reactor 中代表单个返回值的流式对象。我们将在“05 | 顶级框架：Spring 为什么选择 Reactor 作为响应式编程框架”对 Mono 对象进行详细的探讨。

我们再来看一个使用过滤器的场景。以下代码展示了一个用于处理响应的 PostGatewayFilter 的实现方式，其中首先继承一个 AbstractGatewayFilterFactory 类，然后可以通过覆写 apply 方法来提供针对 ServerHttpResponse 对象的任何操作。

```java
public class PostGatewayFilterFactory extends AbstractGatewayFilterFactory {
 
    public PostGatewayFilterFactory() {
        super(Config.class);
    }
 
    public GatewayFilter apply() {
        return apply(o -> {
        });
    }
 
    @Override
    public GatewayFilter apply(Config config) {
        return (exchange, chain) -> {
          return chain.filter(exchange).then(Mono.fromRunnable(() -> {
              ServerHttpResponse response = exchange.getResponse();

              //针对Response的各种处理
            }));
          };
    }
 
    public static class Config {
    }
}
```

同样，注意这里使用了 Reactor 框架中的 then 操作符，该操作符的含义是等到上一个操作完成再做下一个。所以，我们在过滤器链执行完对 exchange 对象的过滤之后，再通过 Mono.fromRunnable 方法创建一个新的线程，可以在这里添加各种针对 Response 对象的处理过程。

### Spring WebFlux 中的请求处理流程

Spring WebFlux 是 Spring 5 中引入的全新的响应式 Web 服务开发框架。针对涉及大量 I/O 操作的服务化架构，WebFlux 也是一种非常有效的解决方案，能够在复杂的流程中集成非阻塞、异步通信机制，从而实现高效处理跨服务之间的网络请求。

在 WebFlux 中，对 HTTP 请求的处理过程涉及了 HandlerMapping、HandlerAdapter、HandlerResultHandler 类之间的交互，整个流程如下图所示。

![](https://s0.lgstatic.com/i/image6/M00/24/04/CioPOWBYDjGAP5oHAADrAy1HQHE514.png)

图 3 WebFlux 处理 HTTP 请求的流程图

我们直接来看用于完成上图流程的 Handle 方法定义，该方法实现了流式处理请求机制，如下所示。

```java
public Mono<Void> handle(ServerWebExchange exchange) {
        if (this.handlerMappings == null) {
            return createNotFoundError();
        }
 
        return Flux.fromIterable(this.handlerMappings)
                //从handlerMapping这个map中获取HandlerMapping
                .concatMap(mapping -> mapping.getHandler(exchange))
                .next()
                //如果没有找到HandlerMapping，则抛出异常
                .switchIfEmpty(createNotFoundError())
                //触发HandlerAdapter的handle方法
                .flatMap(handler -> invokeHandler(exchange, handler))
                //触发HandlerResultHandler 的handleResult方法
                .flatMap(result -> handleResult(exchange, result));
}
```

在这个核心方法中，我们看到了 concatMap、switchIfEmpty 和 flatMap 等响应式操作符。其中的 flatMap 操作符我们在前面已经讨论过。关于这些操作符的具体使用方法，我同样会在第 7 讲为你详细介绍。



---------

# 如何基于Spring框架来学习响应式编程？

## Spring 5 中的响应式编程技术栈

Spring 5 引入了很多核心功能，这其中重要的就是全面拥抱了响应式编程的设计思想和实践。

Spring 5 的响应式编程模型以 Project Reactor 库为基础，而后者则实现了响应式流规范。事实上，Spring Boot 从 2.x 版本开始也是全面依赖 Spring 5。

针对响应式编程技术栈，有一点你需要注意，即响应式编程并不是只针对系统中的某一部分组件，而是需要适用于调用链路上的所有组件。无论是 Web 层、服务层还是处于下游的数据访问层，只要有一个环节不是响应式的，那么这个环节就会出现同步阻塞，从而导致 02 讲中所介绍的背压机制无法生效。这就是所谓的全栈式响应式编程的设计理念。

因此，Spring 5 也针对响应式编程构建了全栈式的开发组件。对于常见的应用程序而言，Web 服务层和数据访问层构成了最基本的请求链路。而 Spring 5 也提供了针对 Web 服务层开发的响应式 Web 框架 WebFlux，以及支持响应式数据访问的 Spring Data Reactive 框架。让我们一起来看一下。

### Spring WebFlux

在 Spring Boot 的基础上，我们将引入全新的 Spring WebFlux 框架。WebFlux 框架名称中的 Flux 一词就来源于 Project Reactor 框架中的 Flux 组件，我会在“06 | 流式操作：如何使用 Flux 和 Mono 高效构建响应式数据流”中对该组件和你展开详细的讨论。

WebFlux 功能非常强大，不仅包含了对创建和访问响应式 HTTP 端点的支持，还可以用来实现服务器推送事件以及 WebSocket。我们无意对该框架的所有功能做全面介绍，对于应用程序而言，开发人员的主要工作是基于 HTTP 协议的响应式服务的开发，这也是本课程内容的一大重点。

下图展示了 spring-boot-starter-webflux 2.2.4 RELEASE 版本的依赖组件，可以看到该版本在 spring-boot-starter 2.2.4 RELEASE 版本的基础上依赖于 spring-webflux 5.2.3.RELEASE 版本，而后者同样依赖 spring-web 5.2.3.RELEASE 版本以及 3.2.3.RELEASE 版本的 reactor-core 组件。

![](https://s0.lgstatic.com/i/image6/M01/21/3A/Cgp9HWBUIkiAV-sbAABUZLGbKGw167.png)

图 1 spring-boot-starter-webflux 的依赖组件

Spring WebFlux 提供了完整的支持响应式开发的服务端技术栈，Spring WebFlux 的整体架构如下图所示。

![](https://s0.lgstatic.com/i/image6/M01/21/37/CioPOWBUIk-ACq-RAACQeZA8Cyk312.png)

图 2 Spring WebFlux 架构图（来自 Spring 官网）

上图针对传统 spring-webmvc 技术栈和新型的 spring-webflux 技术栈做了一个对比。我们从上往下看，位于最上层所提供的实际上是面向开发人员的开发模式，注意左上部分两者存在一个交集，即 Spring WebFlux 既支持基于 @Controller、@RequestMapping 等注解的传统开发模式，又支持基于 Router Functions 的函数式开发模式。本课程后续内容将分别使用这两个模式来创建响应式 RESTful 服务。

关于框架背后的实现原理，传统的 Spring MVC 构建在 Java EE 的 Servlet 标准之上，该标准本身就是阻塞和同步的。在最新版本的 Servlet 中虽然也添加了异步支持，但是在等待请求的过程中，Servlet 仍然在线程池中保持着线程。而 Spring WebFlux 则是构建在响应式流以及它的实现框架 Reactor 的基础之上的一个开发框架，因此可以基于 HTTP 协议用来构建异步非阻塞的 Web 服务。

最后，我们来看一下位于底部的容器支持。显然，Spring MVC 是运行在传统的 Servlet 容器之上，而 Spring WebFlux 则需要支持异步的运行环境，比如 Netty、Undertow 以及 Servlet 3.1 版本以上的 Tomcat 和 Jetty，因为在 Servlet 3.1 中引入了异步 I/O 支持。

由于 WebFlux 提供了异步非阻塞的 I/O 特性，因此非常适合用来开发 I/O 密集型服务。而在使用 Spring MVC 就能满足的场景下，就不需要更改为 WebFlux。通常，我也不大建议你将 WebFlux 和 Spring MVC 混合使用，因为这种开发方式显然无法保证全栈式的响应式流。

### Spring Data Reactive

我们知道 Spring Data 是 Spring 家族中专门针对数据访问而开发的一个框架，针对各种数据存储媒介抽象了一批 Repository 接口以简化开发过程。而在 Spring Data 的基础上，Spring 5 也全面提供了一组响应式数据访问模型。

在介绍如何使用 Spring Data 实现响应式数据访问模型之前，我们再来看一下关于 Spring Boot 2 的另一张官网架构图，如下所示。

![](https://s0.lgstatic.com/i/image6/M01/21/3A/Cgp9HWBUIlmAPXzcAACWjgTTFkY994.png)

图 3 Spring Boot 2 架构图（来自 Spring 官网）

可以看到，上图底部明确把 Spring Data 划分为两大类型，一类是支持 JDBC、JPA 和部分 NoSQL 的传统 Spring Data Repository，而另一类则是支持 Mongo、Cassandra、Redis、Couchbase 等的响应式 Spring Data Reactive Repository。



## 案例驱动：ReactiveSpringCSS

介绍完 Spring 5 中所提供的响应式编程技术栈之后，我们将引出本课程的案例系统 ReactiveSpringCSS，这里的 CSS 是对客户服务系统 Customer Service System 的简称。客户服务是电商、健康类业务场景中非常常见的一种业务场景，我们将通过构建一个精简但又完整的系统来展示 Spring 5 中响应式编程相关的设计理念和各项技术组件。

现实场景下的客户服务业务逻辑一般都非常复杂，而案例系统的目的在于演示技术实现过程，不在于介绍具体业务逻辑。所以，我们对案例的业务流程做了高度的简化，但会包含 Spring 中所提供的各项响应式编程组件。

### ReactiveSpringCSS 整体架构

在 ReactiveSpringCSS 中，存在一个 customer-service，这是一个 Spring Boot 应用程序，也是整个案例系统中的主体服务。该服务将采用经典的分层架构，即将服务分成 Web 层、Service 层和 Repository 层。

我们知道在客服系统中，核心业务是生成客户工单。围绕客户工单的生成过程，ReactiveSpringCSS 的整个系统交互过程如下图所示。

![](https://s0.lgstatic.com/i/image6/M01/21/3A/Cgp9HWBUImGAJDTfAABpy3ZSzWs199.png)

图 4 ReactiveSpringCSS 系统的整体架构图

可以看到，customer-service 一般会与用户账户服务 account-service 进行交互以获取生成工单所需的用户账户信息，但因为用户账户信息的更新属于低频时间，所以我们设计的实现方式是 account-service 通过消息中间件的方式将用户账户变更信息主动推送给 customer-service，从而完成用户信息的获取操作。而针对 order-service，其定位是订单服务，customer-service 也需要从该服务中查询订单信息。

### ReactiveSpringCSS 响应式技术组件

在 ReactiveSpringCSS 的整体架构图中，引出了构建一个响应式系统所需的多项技术组件。

针对 Web 层，我们将使用 Spring WebFlux 组件来分别为 ReactiveSpringCSS 系统中的三个服务构建响应式 RESTful 端点，并通过支持响应式请求的 WebClient 客户端组件来消费这些端点。

在 Service 层，除了完成 Web 层和数据访问层的衔接作用之外，核心逻辑在于完成事件处理和消息通信相关的业务场景。account-service 充当了消息的发布者，而 customer-service 则是它的消费者。为了实现消息通信机制，就需要引入 Spring Cloud 家族中的 Spring Cloud Stream 组件。同样，在 Spring 5 中，也针对 Spring Cloud Stream 做了响应式升级，并提供了对应的响应式编程组件。

最后是 Repository 层，我们将引入 MongoDB 和 Redis 这两款支持响应式流的 NoSQL 数据库。其中 MongoDB 用于为各个服务存储业务数据，而 Redis 则主要用在 customer-service 中，我们把从 account-service 中传入的消息数据缓存在 Redis 中以便提升数据访问的性能。针对这两款 NoSQL，我们将分别引入 Spring 5 中的 Spring Data MongoDB Reactive 和 Spring Data Redis Reactive 进行整合。

当然，对于响应式编程全栈中的各个技术组件，都需要采用有效的测试手段确保其正确性。因此，我们将引入响应式测试组件分别针对响应式流、响应式 Web、响应式消息通信以及响应式数据访问进行全面的测试。

基于以上讨论，ReactiveSpringCSS 所采用的各项响应式编程技术及其应用方式如下图所示。

![](https://s0.lgstatic.com/i/image6/M01/21/3A/Cgp9HWBUImuAJdzJAADUPzZXTjQ358.png)

图 5 ReactiveSpringCSS 系统的响应式技术组件图

我将在后续的课程中对上图中的各个技术组件做专题介绍。





---

# Spring为什么选择Reactor作为响应式编程框架？

Reactor 是响应式领域中具有代表性的类库，实现了响应式流规范，同时已经成为 Spring 框架生态系统的重要组成部分。

今天这一讲，我们就先来分析响应式流的主流实现框架，并探讨 Reactor 中的基础组件。

## 响应式流的主流实现框架

在 Java 领域，目前响应式流的开发库包括 RxJava、Akka、Vert.x 和 Project Reactor 等。这里重点对 RxJava 和 Project Reactor 进行展开描述。

说起 RxJava，我们先来讨论它的前缀 Rx。这里的 Rx 代表的是响应式扩展 Reactive Extensions，实际上它最早诞生于微软的 .NET 平台，用来构建高性能的应用系统，其内部集成了异步数据序列的事件驱动编程。后来，Java 领域也充分借鉴了这一编程模型，诞生了 RxJava 框架，RxJava 可以说是响应式编程得以大规模应用的先驱，推动了一大批针对不同语言的响应式编程框架，这些编程框架同样都以 Rx 作为前缀，例如 RxSwift、RxRuby、RxGo，RxScale、RxKotlin 等。

RxJava 从最初的 1.x 发展到现在的 3.x 版本，各个版本之间变化较大。而从 2.x 版本开始，就对原有的 API 按照响应式流规范进行了重构，并提供了独立的背压功能。RxJava 应用广泛，例如，在 Netflix 的微服务套件中，熔断器 Hystrix、客户端负载均衡器 Ribbon、API 网关 Zuul 等常用组件中都使用到了 RxJava。除此之外，在以 Android 为代表的 UI 交互开发领域，RxJava 也普遍受到开发人员的欢迎。可以说，其他 Rx 开发库的兴起很大程度上归功于 RxJava 的发展。

聊完 RxJava，我们再来看 Reactor。相较于 RxJava，Reactor 诞生在响应式流规范制定之后，所以从一开始就是严格按照响应式流规范设计并实现了它的 API，这也是 Spring 选择它作为默认响应式编程框架的核心原因。

在发展过程中，Reactor 同样经历到从 1.X 到目前 3.X 的演进历程。Reactor 库自早期版本以来已经发展了很多，目前最新的 3.X 版本以 Java 8 作为基线，可以说已经成为业界最先进的响应式库。

RxJava 和 Reactor 二者对比来说，虽然 RxJava 诞生得更早，但 Reactor 应该更有前途。为什么这样说，因为它的开发更活跃，并得到了 Pivotal 公司的大力支持。从 API 角度看，这些库都非常相似，也都提供了一大批非常实用的操作符来简化开发过程。但既然 Spring 5 选择了 Reactor，就让我们来学习它吧。

## Project Reactor 框架

Reactor 框架可以单独使用。和集成其他第三方库一样，如果想要在代码中引入 Reactor，要做的事情就是在 Maven 的 pom 文件中添加如下依赖包。

```xml
<dependency>
    <groupId>io.projectreactor</groupId>
    <artifactId>reactor-core</artifactId>
</dependency>
	 
<dependency>
    <groupId>io.projectreactor</groupId>
    <artifactId>reactor-test</artifactId>
    <scope>test</scope>
</dependency>
```

其中 reactor-core 包含了 Reactor 的核心功能，而 reactor-test 则提供了支持测试的相关工具类。在本讲的后续内容中，我将从 Reactor 框架所提供的异步数据序列入手，引出该框架所提供的 Flux 和 Mono 这两个核心编程组件以及相关的操作符。最后，作为响应式流的核心，我们也会对它所具备的背压机制进行讨论。

#### Reactor 异步数据序列

响应式流规范的基本组件是一个异步的数据序列，在 Reactor 框架中，我们可以把这个异步数据序列表示成如下形式。

![](https://s0.lgstatic.com/i/image6/M00/26/8D/CioPOWBbFBCAQDDNAACGnB65zn8934.png)

图 1 Reactor 框架异步序列模型

上图中的异步序列模型从语义上可以用如下公式表示。

```xml
onNext x 0..N [onError | onComplete]
```

显然，以上公式中包含了三种消息通知，分别对应在异步数据序列执行过程中的三种不同数据处理场景，其中：

- onNext 表示正常的包含元素的消息通知；
- onComplete 表示序列结束的消息通知；
- onError 表示序列出错的消息通知。

结合上一讲的内容，当触发这些消息通知时，异步序列的订阅者中对应的这三个同名方法将被调用。正常情况下，onNext() 和 onComplete() 方法都应该被调用，用来正常消费数据并结束序列。如果没有调用 onComplete() 方法就会生成一个无界数据序列，在业务系统中，这通常是不合理的。而 onError() 方法只有序列出现异常时才会被调用。

基于上述异步数据序列，Reactor 框架提供了两个核心组件来发布数据，分别是 Flux 和 Mono 组件。这两个组件可以说是应用程序开发过程中最基本的编程对象。

### Flux 和 Mono 组件

Flux 代表的是一个包含 0 到 n 个元素的异步序列，Reactor 官网给出了它的示意图，如下所示。

![](https://s0.lgstatic.com/i/image6/M00/26/91/Cgp9HWBbFCaAPHNNAAIMnXsm0_I218.png)

图 2 Flux 组件（来自 Reactor 官网）

上图中的“operator”代表的是操作符，红色的叉号代表异常，而最后的一个符号则代表序列正常结束。显然，序列的三种消息通知都适用于 Flux。在详细介绍 Flux的构建和使用方法之前，我们先通过一段简短的代码来演示使用 Flux 的方法，如下所示。

 